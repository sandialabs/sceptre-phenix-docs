{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This is the documentation for the minimega <code>phenix</code> orchestration tool.  <code>phenix</code> development happens in the sandialabs/sceptre-phenix  GitHub repository.</p>"},{"location":"#getting-started-with-phenix","title":"Getting Started with ph\u0113nix","text":"<p>The first step in using <code>phenix</code> is to get it installed. <code>phenix</code> needs access to the minimega unix socket, so the best place to deploy it is on a  minimega cluster's head node. The minimega unix socket will be located at <code>/tmp/minimega/minimega</code> on default cluster deployments and will be owned by root, so unless the socket's group ownership and group write permissions have been updated, <code>phenix</code> will need to be run as root in order to access the socket.</p> <p>Note</p> <p>In most cases, it's much easier to deploy the latest version of both ph\u0113nix and minimega with Docker (see next section).  The ph\u0113nix repository includes a Docker Compose file that will always  ensure the required versions are working together correctly.</p>"},{"location":"#installing-and-running-via-docker","title":"Installing and Running via Docker","text":"<p>The ph\u0113nix repository includes Docker resources in the <code>docker</code> directory. By far the easiest way to get ph\u0113nix up and running is to use the  Docker Compose configuration located at <code>docker/docker-compose.yml</code>. This will ensure that the latest required version of minimega is also present and configured with the additional Linux tools required to operate correctly with ph\u0113nix.</p> <p>To run ph\u0113nix and minimega using Docker Compose, run the following command from the <code>docker</code> directory.</p> <pre><code>docker compose up -d --build\n</code></pre> <p>The above command will first build the phenix Docker image and then start all the Docker services defined in the compose file in detached mode.</p> <p>Besides ph\u0113nix and minimega, there are two additional services defined in the compose file; one for Elasticsearch and one for Kibana. These are included in the compose file because they're often used with the Scorch ph\u0113nix application. If you don't need the Elasticsearch and Kibana services, you can prevent them from being started by specifying that only the <code>phenix</code> service (and its dependency service <code>minimega</code>) be brought up.</p> <pre><code>docker compose up -d --build phenix\n</code></pre> <p>Note</p> <p>The Docker image will also include the <code>phenix</code> user apps available in the sandialabs/sceptre-phenix-apps repo.</p> <p>With <code>phenix</code> running in a container, it's useful to setup a bash alias for <code>phenix</code>:</p> <pre><code>alias phenix=\"docker exec -it phenix phenix\"\n</code></pre> <p>Included below are explanations of some of the configuration options chosen to be used in the Docker Compose file.</p> <p>The Docker <code>privileged</code> mode, along with the <code>/dev</code> and <code>/proc</code> volume mounts, are needed for building QCOW2 VM images with ph\u0113nix. They can be omitted if ph\u0113nix won't be used to build images.</p> <p>The <code>/var/log/phenix</code> volume mount is shared with the host to make debugging failed container issues easier, since ph\u0113nix writes logs to <code>/var/log/phenix</code>  by default when run as root.</p> <p>The <code>/etc/phenix</code> volume mount is shared with the host to persist ph\u0113nix configuration changes across container restarts, since the ph\u0113nix configuration store is written to <code>/etc/phenix/store.bdb</code> by default when run as root.</p> <p>The <code>/var/run/netns</code> volume mount is shared with the host to synchronize  network namespaces created by ph\u0113nix taps between the ph\u0113nix and minimega containers.</p> <p>The <code>/phenix</code> volume mount is used as the base directory for ph\u0113nix by default (see <code>--base-dir.phenix</code> global option), so we share this directory with the host to persist changes across container restarts.</p>"},{"location":"#simplified-deployment","title":"Simplified deployment","text":"<p>The simplified deployment will deploy the latest version of phenix and minimega  without building from source, instead using the latest version of the phenix  Docker image pulled from GitHub.</p> <p>The primary differences are: - Uses pre-build phenix Docker image from GitHub - No Elasticsearch or Kibana services</p> <pre><code>git clone https://github.com/sandialabs/sceptre-phenix.git\ncd sceptre-phenix/docker\n\n# Start phenix and minimega containers\ndocker compose -f no-build_docker-compose.yml up -d --pull\n\n# Run the following command and wait until minimega and phenix finish initializing\ndocker compose logs -f\n# CTRL+C to exit\n</code></pre>"},{"location":"#building-from-source","title":"Building from Source","text":"<p>The easiest way to build from source is to use the Docker-based build script located at <code>hack/build/docker-build.sh</code> by running the following command from the root directory of the repository.</p> <pre><code>hack/build/docker-build.sh\n</code></pre> <p>Once the build is finished, there will be a <code>phenix</code> executable located in the <code>bin</code> directory. For additional usage details, pass the <code>-h</code> option to the  build script.</p>"},{"location":"#using","title":"Using","text":"<p>The following output results from <code>bin/phenix help</code>:</p> <pre><code>A cli application for ph\u0113nix\n\nUsage:\n  phenix [flags]\n  phenix [command]\n\nAvailable Commands:\n  config      Configuration file management\n  experiment  Experiment management\n  help        Help about any command\n  image       Virtual disk image management\n  mm          Send commands, or attach, to minimega\n  settings    View or edit phenix settings\n  ui          Run the phenix UI\n  util        Utility commands\n  version     print version information\n  vlan        Used to manage VLANs\n  vm          Virtual machine management\n\nFlags:\n      --base-dir.minimega string   base minimega directory (default \"/tmp/minimega\")\n      --base-dir.phenix string     base phenix directory (default \"/phenix\")\n      --bridge-mode string         bridge naming mode for experiments ('auto' uses experiment name for bridge; 'manual' uses user-specified bridge name, or 'phenix' if not specified) (options: manual | auto) (default \"manual\")\n      --deploy-mode string         deploy mode for minimega VMs (options: all | no-headnode | only-headnode) (default \"no-headnode\")\n      -h, --help                   help for phenix\n      --hostname-suffixes string   hostname suffixes to strip (default \"-minimega,-phenix\")\n      --log.error-file string      log fatal errors to file - DEPRECATED (Determined by log.file.level)\n      --log.error-stderr           log fatal errors to STDERR - DEPRECATED (Determined by log.level) (default true)\n      --log.file.level string      level to log messages at for log file (options: debug | info | warn | error | none) (default \"info\")\n      --log.file.path string       path to log to (default \"/var/log/phenix/phenix.log\")\n      --log.level string           level to log messages at (default \"info\")\n      --store.endpoint string      endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\")\n      --unix-socket string         ph\u0113nix unix socket to listen on (ui subcommand) or connect to (default \"/tmp/phenix.sock\")\n      --use-gre-mesh               use GRE tunnels between mesh nodes for VLAN trunking\n\nUse \"phenix [command] --help\" for more information about a command.\n</code></pre> <p>Thanks to viper, it is possible to specify values for all of the global and <code>ui</code> command flags listed above using a configuration file. Global flags set at the command line will override  settings in the configuration file. phenix looks for a configuration in the following  locations.</p> <p>When run as root (not including sudo):</p> <pre><code>/etc/phenix/config.[yaml|json|toml]\n</code></pre> <p>When run as regular user (including sudo):</p> <pre><code>$HOME/.config/phenix/config.[yaml|json|toml]\n/etc/phenix/config.[yaml|json|toml]\n</code></pre> <p>An example configuration file might look like the following:</p> <pre><code>base-dir:\n  minimega: /tmp/minimega\n  phenix: /phenix\nlog:\n  error-file: /var/log/phenix/error.log\n  error-stderr: true\nstore:\n  endpoint: bolt:///etc/phenix/store.bdb\nui:\n  listen-endpoint: 0.0.0.0:3000\n  jwt-signing-key: abcde12345\n  log-level: info\n  log-verbose: true\n  logs:\n    phenix-path: /var/log/phenix/phenix.log\n    minimega-path: /var/log/minimega/minimega.log\n</code></pre> <p>Environment variables can also be used to set global and <code>ui</code> command flags. The environment variables must be prefixed with <code>PHENIX_</code>, with the rest of the variable matching the flag name with <code>-</code> and <code>.</code> replaced with <code>_</code>. For example, <code>--store.endpoint</code> becomes <code>PHENIX_STORE_ENDPOINT</code>.</p> <p>Further documentation on the available commands can be found at:</p> <ul> <li>config</li> <li>experiment</li> <li>vm</li> <li>image</li> </ul>"},{"location":"#store","title":"Store","text":"<p>The phenix tool uses a key-value data store as the storage service for all of data needed throughout the various capabilities (as opposed to a database). By default it uses bbolt but also supports etcd. <code>bbolt</code> is used by default because it has no external dependencies, but has a limitation of only being accessible on  a single machine. Using <code>etcd</code>, on the other hand, allows for users to run <code>phenix</code> on multiple machines and access the same data, but requires <code>etcd</code> be deployed as a separate service.</p> <p>To use <code>etcd</code>, the <code>--store.endpoint</code> global flag should be configured with the URL of the deployed <code>etcd</code> server. For example, <code>--store.endpoint etcd://localhost:2379</code>.</p>"},{"location":"apps/","title":"Apps","text":"<p><code>phenix</code> apps provide a means of modifying an experiment topology, cluster networking, hardware-in-the-loop devices, etc. in a layered, scripted, and codified manner. <code>phenix</code> itself includes four (4) default apps that get applied to every experiment by default. In addition to the default apps, it is possible to apply user apps to an experiment using a scenario configuration.</p>"},{"location":"apps/#default-apps","title":"Default Apps","text":"ntp provides/configures NTP service for experiment serial configures serial interfaces in VM images startup configures minimega startup injections based on OS type vrouter customizes Vyatta/VyOS and minirouter routers, including setting interfaces, ACL rules, etc."},{"location":"apps/#vrouter-app","title":"vrouter App","text":"<p>As of commit <code>e276a5b</code>, the <code>vrouter</code> app also supports the use of minimega's <code>minirouter</code> to include interface configuration, DHCP and DNS configuration, firewall rules, etc.</p> <p>The following is an example of how the <code>vrouter</code> app can be configured via a <code>Scenario</code> configuration, showing all the possible options.</p> <p>Warning</p> <p>Some configuration sections only apply to Vyatta/VyOS and do nothing for a node marked as <code>minirouter</code>. See notes below or the source for more details.</p> vrouter example<pre><code>spec:\n  apps:\n    - name: vrouter\n      hosts:\n        - hostname: rtr\n          metadata:\n            ipsec:\n              - local: 10.0.10.2\n                remote 10.0.40.2\n                peer: rtr2\n                tunnels:\n                  - local: 192.168.10.0/24\n                    remote: 192.168.100.0/24\n            acl:\n              ingress:\n                eth0: in-rules\n              rulesets:\n                - name: in-rules\n                  default: drop\n                  rules:\n                    - id: 10\n                      action: accept\n                      description: Allow Incoming HTTP\n                      source:\n                        address: 192.168.0.0/24\n                      destination:\n                        address: 10.0.0.0/24\n                        port: 80\n                      protocol: tcp\n                    - id: 20\n                      action: accept\n                      description: Allow Established\n                      stateful: true\n                      protocol: all\n            dhcp:\n              - listenAddress: 10.0.0.254\n                ranges:\n                  - lowAddress: 10.0.0.10\n                    highAddress: 10.0.0.20\n                defaultRoute: 10.0.0.254\n                dnsServers:\n                  - 10.0.0.254\n                staticAssignments:\n                  00:00:00:00:00:AA: 10.0.0.50\n              - listenAddress: 192.168.0.254\n                ranges:\n                  - lowAddress: 192.168.0.10\n                    highAddress: 192.168.0.20\n                defaultRoute: 192.168.0.254\n                dnsServers:\n                  - 192.168.0.254\n                staticAssignments:\n                  00:00:00:00:00:BB: 192.168.0.50\n            dns:\n              1.2.3.4: foo.com\n            snat:\n              - interface: eth0\n                srcAddr: 192.168.0.0/24\n                translation: masquerade\n            dnat:\n              - interface: eth1\n                dstAddr: 10.0.0.1\n                dstPort: 80\n                protocol: tcp\n                translation: 192.168.0.250:8080\n            emulators:\n              - egress:\n                  - eth0\n                  - eth1\n                name: comcast\n                bandwidth: 400kbit\n                delay: 500\n                corruption: 5\n                loss: 10\n                reordering: 5\n</code></pre> <ul> <li> <p><code>ipsec</code>: if present, point-to-point IPSec tunnels are nailed up between the   list of given IP addresses and traffic between the given networks is tunneled.</p> <ul> <li> <p><code>local</code>: Local IP address for IPSec connection with this peer. If defined   any, then an IP address which configured on interface with default route   will be used. It must have a route to the <code>peer</code> IP address.</p> </li> <li> <p><code>remote</code>: Remote IP address or hostname for IPSec connection. IPv4 or   IPv6 address is used when a peer has a public static IP address.   Hostname is a DNS name which could be used when a peer has a public   IP address and DNS name, but an IP address could be changed from time   to time. It must have a route to the <code>peer</code> IP address.</p> </li> <li> <p><code>peer</code>: Name of peer connection. The peer name must be an alphanumeric   and can have hypen or underscore as special characters. It is purely   informational.</p> </li> <li> <p><code>tunnels</code>: list of local and remote networks to tunnel through this   point-to-point connection.</p> <ul> <li> <p><code>local</code>: local network to tunnel to the given remote network.</p> </li> <li> <p><code>remote</code>: remote network to tunnel to the given local network.</p> </li> </ul> </li> </ul> </li> <li> <p><code>acl</code>: if present, access control lists (ACLs / firewall rules) are created on   the router per the defined rulesets.</p> <ul> <li> <p><code>ingress</code>: for each interface-to-ruleset mapping, apply the given ruleset   to the given interface for inbound traffic. Note that the interface name   used (in this example, <code>eth0</code>) refers to the name given to a network   interface in the router's topology configuration.</p> </li> <li> <p><code>egress</code>: for each interface-to-ruleset mapping, apply the given ruleset   to the given interface for outbound traffic.</p> </li> <li> <p><code>rulesets</code>: list of rulesets to create on the router.</p> <ul> <li> <p><code>name</code>: name of the ruleset; used in the interface-to-ruleset mapping   in the <code>ingress/egress</code> sections.</p> </li> <li> <p><code>default</code>: default action to apply to traffic that doesn't match any   rules.</p> </li> <li> <p><code>rules</code>: list of rules to apply to traffic.</p> <ul> <li> <p><code>id</code>: integer to identify the order of the rules in the set.</p> </li> <li> <p><code>action</code>: action to apply to traffic matching rule.</p> </li> <li> <p><code>source</code>: map describing what source to limit matching traffic to.   If not provided, all sources are matched.</p> <ul> <li> <p><code>address</code>: source address to limit matching traffic to. If not   provided, all source addresses are matched.</p> </li> <li> <p><code>port</code>: source port to limit matching traffic to. If not   provided, all source ports are matched.</p> </li> </ul> </li> <li> <p><code>destination</code>: map describing what destination to limit matching   traffic to. If not provided, all sources are matched.</p> <ul> <li> <p><code>address</code>: destination address to limit matching traffic to.   If not provided, all destination addresses are matched.</p> </li> <li> <p><code>port</code>: destination port to limit matching traffic to. If not   provided, all destination ports are matched.</p> </li> </ul> </li> <li> <p><code>protocol</code>: IP protocol to limit matching traffic to. Must be   provided; to allow all protocols, use the <code>all</code> keyword.</p> </li> <li> <p><code>stateful</code>: if true, enable established and related traffic for   this ruleset.</p> </li> </ul> </li> </ul> </li> </ul> </li> <li> <p><code>dhcp</code>: if present, DHCP is configured on the router per the provided list.</p> <ul> <li> <p><code>listenAddress</code>: IP address on a local interface (e.g. this router) to   bind this DHCP configuration to.</p> </li> <li> <p><code>ranges</code>: list of IP address low/high ranges to use for DHCP assignments.   The IP addresses must be within the IP network of the <code>listenAddress</code>.</p> </li> <li> <p><code>defaultRoute</code>: default gateway to be included in DHCP leases.</p> </li> <li> <p><code>dnsServers</code>: list of DNS servers to be included in DHCP leases.</p> </li> <li> <p><code>staticAssignments</code>: map of MAC-to-IP assignments to use for static DHCP   addresses.</p> </li> </ul> </li> <li> <p><code>dns</code>: if present, map of IP-to-domain DNS entries to create on the router.</p> </li> <li> <p><code>emulators</code>: if present, a list of network emulator traffic policies to apply   to one or more interfaces on egress. For each emulator in the list, only the   <code>name</code> key is required, though the traffic policy will not get applied if   there's not at least one <code>egress</code> interface defined.</p> <ul> <li> <p><code>name</code>: unique name of traffic policy for this router.</p> </li> <li> <p><code>egress</code>: list of interface names to apply traffic policy to on egress.   The names listed should be the same names used for network interfaces in   the topology.</p> </li> <li> <p><code>bandwidth</code>: maximum allowed bandwidth for interface and direction this   traffic policy is applied to.</p> </li> <li> <p><code>delay</code>: fixed amount of time to add to all packets for interface and   direction this traffic policy is applied to.</p> </li> <li> <p><code>corruption</code>: percentage of corrupted packets for interface and direction   this traffic policy is applied to.</p> </li> <li> <p><code>loss</code>: percentage of lost packets for interface and direction this   traffic policy is applied to.</p> </li> <li> <p><code>reordering</code>: percentage of reordered packets for interface and direction   this traffic policy is applied to.</p> </li> </ul> </li> </ul> <p>Important</p> <p>The <code>ingress</code> and <code>egress</code> setting for ACLs are from the perspective of the network segment the specified interface is connected to, not from the perspective of the interface itself. For example, if <code>eth0</code> on a router is connected to VLAN <code>EXP_01</code>, then specifying <code>eth0: in-rules</code> for the <code>ingress</code> setting means the rules specified in the <code>in-rules</code> ruleset will be applied to packets \"ingressing into\" VLAN <code>EXP_01</code>. Under the hood, the rules are actually applied to packets \"egressing out of\" interface <code>eth0</code>.</p> <p>Note</p> <p>Currently, the <code>ipsec</code>, <code>emulators</code>, and <code>snat</code>/<code>dnat</code> metadata sections only apply to Vyatta/VyOS routers.</p> <p>Note</p> <p>Currently, the <code>stateful</code> setting for ACL rules only applies to Vyatta/VyOS routers.</p> <p>Note</p> <p>Currently, the <code>dhcp</code> and <code>dns</code> metadata sections only apply to minirouter routers.</p> <p>Note</p> <p>Currently, the only emulator policy used is network-emulator and it only applies to outbound traffic (egress).</p>"},{"location":"apps/#additional-core-apps","title":"Additional Core Apps","text":"<p>The apps listed below are provided by the core <code>phenix</code> application, but are not considered default apps since they do not get applied to every experiment by default. They're more like a user app, but implemented in the core application instead of as a stand-alone executable.</p> scorch Scorch \u2014 SCenario ORCHestration \u2014 is an automated scenario orchestration framework within phenix soh provide state of health monitoring for an experiment tap manage host taps (typically used for external network access) for an experiment"},{"location":"apps/#tap-app","title":"tap App","text":"<p>The <code>tap</code> app manages the creation and removal of host taps needed by experiments to access external network resources. This includes creating the tap in a network namespace (<code>netns</code>) to avoid interface address collisions with other experiments, connecting the netns with the system network to enable external network access, and modifying iptables to allow external network access from the tapped experiment VLAN.</p> <p>Note</p> <p>Host taps can also be used to access VM network resources directly from the host the VM is running on. This is an advanced topic that will be documented soon.</p> <p>In order for a tap to have access to experiment VMs in the tapped VLAN, it must have an IP address on the same subnet as the rest of the VMs in the VLAN. Attempting to tap multiple experiments could fail if the VLANs being tapped are using the same subnet, so the tap is put into a netns to provide isolation and avoid address collisions.</p> <p>With the tap in a netns, however, it no longer has a path to external networks via the system's default netns. To remedy this, a <code>veth pair</code> is used to connect the tap's netns with the default netns. A very small (<code>/30</code>) IP subnet is used for the veth pair, and phenix manages the selection and tracking of the subnets used for each pair to avoid collisions.</p> <p>With the veth pair in place, packets from the experiment VLAN can now be routed externally with the help of IP masquerading in both the tap's netns and the default netns.</p> <p>Warning</p> <p>This has not been fully tested against all the possible iptables firewall configurations. If you experience problems with external access, it may be due to a more restrictive iptables configuration than we've tested with.</p> <p>The following is an example of how the <code>tap</code> app can be configured via a <code>Scenario</code> configuration, showing all the possible options.</p> <p>Note</p> <p>The <code>externalAccess.firewall</code> portion of the tap configuration has not been implemented yet.</p> tap app example<pre><code>spec:\n  apps:\n    - name: tap\n      metadata:\n        taps:\n            # the bridge to add the tap to (will default to 'phenix' if not provided)\n          - bridge: phenix\n            # the experiment VLAN to tap\n            vlan: MGMT\n            # IP address to use for host tap -- VMs on the tapped VLAN would use this\n            # address as their gateway if they need external access (and it's enabled\n            # below)\n            ip: 172.20.5.254/24\n            # IP subnet to use for veth pair between host and tap's network\n            # namespace when external access is enabled (will default to a /30\n            # subnet that is not already in use by any other running experiment if\n            # not provided)\n            subnet: 10.213.47.8/30\n            externalAccess:\n              # defaults to false\n              enabled: true\n              # this section is planned, but not implemented yet\n              firewall:\n                # default action to take if none of the rules below match a packet\n                default: drop\n                rules:\n                    # action to take if a packet matches this rule\n                  - action: accept\n                    description: Only allow web access\n                    source:\n                      # can also use `addresses` to specify a list of addresses\n                      address: 172.20.5.0/29\n                    destination:\n                      address: 10.0.0.0/24\n                      # can also use `port` to specify a single port\n                      ports: [80, 443]\n                    # can also use `protocols` to specify a list of protocols\n                    protocol: tcp\n</code></pre>"},{"location":"apps/#user-apps","title":"User Apps","text":"<p><code>phenix</code> user apps are stand-alone executables that <code>phenix</code> shells out to at different stages of the experiment lifecycle ( <code>configure</code>, <code>pre-start</code>, <code>post-start</code>, <code>running</code>, and <code>cleanup</code>). When <code>phenix</code> encounters an app in an experiment scenario that isn't a default app, it checks to see if an executable exists in its current <code>PATH</code> in the form of <code>phenix-app-&lt;app name&gt;</code>. If the executable exists, <code>phenix</code> shells out to it, providing the current lifecycle stage as an argument and providing the experiment <code>metadata</code>, <code>spec</code>, and <code>status</code> as a JSON string over <code>STDIN</code>.</p> <p>Note</p> <p>There will be three (3) top-level keys available in the JSON passed to a user app over <code>STDIN</code>: <code>metadata</code>, <code>spec</code>, and <code>status</code>. For the <code>configure</code> and <code>pre-start</code> stages, the <code>status</code> value will be null or otherwise ignored. The <code>spec</code> value will be experiment schema.</p> <p>Tip</p> <p>You can run <code>phenix util app-json &lt;exp name&gt;</code> to see an example of what the JSON that's passed to a user app looks like.</p> <p>The user app can modify the experiment at will, then return the updated JSON over <code>STDOUT</code> and exit with a <code>0</code> status. If the user app encounters an error, it can print any error messages to <code>STDERR</code> and exit with a non-zero status to signal to <code>phenix</code> that an error occurred.</p> <p>Note</p> <p><code>phenix</code> will only process updates to the <code>spec</code> value for the <code>configure</code> and <code>pre-start</code> stages, and will only process updates to the <code>status</code> value for the <code>post-start</code>, <code>running</code>, and <code>cleanup</code> stages. More specifically, it will only process updates to <code>status.apps.&lt;app name&gt;</code>, which can be anything the app wants it to be (e.g. a simple string, an array, or a map/dictionary).</p> <p>Note</p> <p>It is possible for the execution of app stages to be canceled by the caller. In the case of user apps, <code>phenix</code> will send a <code>SIGTERM</code> to the user app process and wait a maximum of 10 seconds for the process to exit gracefully before killin the process with a <code>SIGKILL</code>.</p>"},{"location":"apps/#available-user-apps","title":"Available User Apps","text":"<p>The sandialabs/sceptre-phenix-apps repo is home to some user apps that have already been created by the community, including the following:</p> App Link Description caldera link Deployment and orchestration of MITRE Caldera in an experiment helics link Aids in the generation of HELICS broker start scripts and injects them into the appropriate nodes in an experiment otsim link Aids in the generation of config files for OT-sim protonuke link Configures the protonuke traffic generator sceptre link Core functionality for SCEPTRE, including generating configs for field devices (bennu), SCADA systems, and other systems. wind_turbine link wireguard link Configures Wireguard on VMs mirror link The mirror app configures cluster-wide packet mirroring for specific VLANs to a specific interface on a predefined node using GRE tunnels. It is written in Golang. <p>In addition, this repo also contains some generic library/utility code for making custom user app development easier. See the README for additional details.</p>"},{"location":"apps/#example","title":"Example","text":"<p>Below is a very contrived example of a simple user app that changes the disk image used for every node in the experiment topology. Assuming the name of the executable for this app as <code>phenix-app-image-changer</code>, it could be applied to a topology by including a scenario in an experiment that includes an experiment app named <code>image-changer</code>.</p> <pre><code>import json, sys\n\n\ndef eprint(*args):\n    print(*args, file=sys.stderr)\n\n\ndef main() :\n    if len(sys.argv) != 2:\n        eprint(\"must pass exactly one argument on the command line\")\n        sys.exit(1)\n\n\n    raw = sys.stdin.read()\n\n    if sys.argv[1] != 'pre-start':\n        print(raw)\n        sys.exit(0)\n\n\n    exp = json.loads(raw)\n    spec = exp['spec']\n\n    for n in spec['topology']['nodes']:\n        for d in n['hardware']['drives']:\n            d['image'] = 'm$.qc2'\n\n\n    print(json.dumps(exp))\n</code></pre>"},{"location":"configuration/","title":"Configuration Files","text":"<p><code>phenix</code> currently supports six (6) different configuration file types:</p> <ol> <li>Topology</li> <li>Scenario</li> <li>Experiment</li> <li>Image</li> <li>User</li> <li>Role</li> </ol> <p>Typically, users will create <code>Topology</code> and <code>Scenario</code> configuration files by hand, while the rest will be generated by <code>phenix</code> using available commands. However, it is possible to create all configuration file types by hand if necessary.</p> <p>Note</p> <p>Configuration files can also be created, viewed, and deleted via the Web-UI (see Web-UI section below).</p> <p>Configuration files are versioned using a header section based heavily on what Kubernetes does. Each configuration file will have a header section that looks like the following:</p> <pre><code>apiVersion: phenix.sandia.gov/v1\nkind: Topology\nmetadata:\n  name: foobar\nspec:\n  ...\n</code></pre> <p>In the example above, the <code>kind</code> field represents the type of configuration file (e.g., Topology, Scenario, Image). The <code>apiVersion</code> field represents the version the <code>spec</code> section conforms to (currently there is only <code>v1</code> for all configuration types except <code>Scenario</code>, which is <code>v2</code>), and the <code>spec</code> section will contain the actual details for the configuration type based on the configuration schema. Note that, at least in the header section, keys are camel-case and begin with a lowercase letter, while values are camel-cased but begin with a capital letter.</p> <p>Note</p> <p>Throughout the documentation, we mention <code>creating configurations manually</code>. When we say this, we mean passing a YAML or JSON configuration file of any type to the <code>phenix config create</code> command.</p>"},{"location":"configuration/#topology","title":"Topology","text":"<p>The <code>Topology</code> configuration is one of the core configuration types for <code>phenix</code>, as it describes a network topology to be deployed in <code>minimega</code> that can be used by one or more experiments to be executed.</p> <p>A topology is comprised of one or more nodes, which can either be a VM (<code>external: false</code> - the default) or an external node (<code>external: true</code>), each including system descriptions and configurations, as well as any networking settings required to connect all of the nodes in a topology together. This configuration becomes the basis for most of the minimega commands later created in the relevant minimega startup script (at least for internal VMs).</p>"},{"location":"configuration/#default-settings","title":"Default Settings","text":"<p>If left unmodified or unset, the following are the default settings for each node:</p> <ul> <li>external will be set to <code>false</code></li> <li>memory will be set to <code>512</code>MB</li> <li>vcpus will be set to <code>1</code></li> <li>snapshot will be set to <code>true</code></li> <li>no network settings will be included</li> </ul>"},{"location":"configuration/#required-values","title":"Required Values","text":"<p>Each topology must have a unique name, which should be lowercase and not include spaces. In addition, each node in the topology must:</p> <ul> <li>have a specified type \u2014 the available types are defined in the   schema</li> <li>have a unique hostname</li> <li>have an OS type of <code>linux</code> or <code>windows</code></li> <li>have a disk image assigned</li> </ul>"},{"location":"configuration/#optional-values","title":"Optional Values","text":"<p>Optional values for a node in the topology configuration can include:</p> <ul> <li>static network configurations</li> <li>specific memory values (e.g., <code>1-16</code>GB)</li> <li>specific VCPUs values (e.g., <code>1-4</code>)</li> <li>additional disk storage</li> <li>file injections</li> <li>labels, which are typically used by ph\u0113nix apps</li> <li>routing ruleset(s)</li> <li>delay triggered by <code>user</code>, <code>time</code>, or <code>c2</code> (command and control)</li> </ul>"},{"location":"configuration/#delay-start","title":"Delay Start","text":"<p>It is possible to delay the start of a VM with the <code>delay</code> value. There are three options available to set, but on only one option can be set:</p> <ol> <li> <p><code>user</code> is a boolean value and when set to <code>true</code> the VM will require a manual    start either through the ph\u0113nix UI or command line (the latter can be by    ph\u0113nix or minimega commands).</p> </li> <li> <p><code>time</code> is a string that is set as a delay in minutes; e.g., <code>5m</code>.</p> </li> <li> <p><code>c2</code> requires minimega command and control. Note in the example below that    the hostname <code>AD1</code> will be delayed starting until the VM <code>host-00</code> has    started and checked in with minimega command and control. It is possible to    have multiple hostnames included. <code>useUUID</code> is an additional boolean value    setting, per hostname, that will watch for the UUID instead of the hostname    to register with minimega command and control.</p> </li> </ol> <p>Note</p> <p>If one or more VMs are set with a delayed start, the UI will display a blue tag in the Delay column next to the Screenshot column. The tag will indicate what type of dealy was set. Once all the delayed VMs have started, the Delay column will no longer be visible.</p>"},{"location":"configuration/#network-address-translation-nat","title":"Network Address Translation (NAT)","text":"<p>For nodes of type <code>Router</code>, basic source NAT can be configured to masquerade packets from one or more networks out a specific interface. For example, assume a router has three interfaces \u2014 <code>eth0, eth1, eth2</code>. <code>eth0</code> is connected to the Internet, while <code>eth1, eth2</code> are connected to networks that use private IP space. To masquerade packets from <code>eth1, eth2</code> out <code>eth0</code> the following configuration could be used.</p> <pre><code>network:\n  nat:\n    - out: eth0\n      in:\n        - eth1\n        - eth2\n</code></pre>"},{"location":"configuration/#external-nodes","title":"External Nodes","text":"<p>There may be cases where an experiment includes external devices (hardware in the loop) that should still be included in the topology for the purposes of the State of Health network diagram, state of health reachability checks, or for use by custom user apps. External nodes can be included in the topology by marking them as <code>external: true</code>. Among other things, this will prevent them from being deployed as a VM in minimega. The configuration schema for an external node in the topology is defined here.</p> <p>Warning</p> <p>Do not use <code>external: false</code> for internal nodes that should be deployed in minimega. Instead, don't include the <code>external</code> configuration key at all. This is a quirk of how we internally decide which node schema should be used (via <code>oneOf</code>).</p>"},{"location":"configuration/#example","title":"Example","text":"<p>A contrived, four node example \u2014 three VMs and a router \u2014 is given below, and is driven by the topology schema described here.</p> <pre><code>apiVersion: phenix.sandia.gov/v1\nkind: Topology\nmetadata:\n  name: foobar\nspec:\n  nodes:\n  - type: VirtualMachine\n    general:\n      hostname: host-00\n      snapshot: true\n    delay:\n      user: true\n    hardware:\n      os_type: linux\n      drives:\n      - image: ubuntu.qc2\n    injections:\n      - src: foo/bar/sucka.fish\n        dst: /data/sucka.fish\n      - src: /foo/bar/sucka/fish.sh\n        dst: /data/fish.sh\n    network:\n      interfaces:\n      - name: IF0\n        vlan: EXP-1\n        address: 192.168.10.1\n        mask: 24\n        gateway: 192.168.10.254\n        proto: static\n        type: ethernet\n      - name: IF1\n        vlan: MGMT\n        address: 172.16.10.1\n        mask: 16\n        proto: static\n        type: ethernet\n  - type: VirtualMachine\n    general:\n      hostname: host-01\n      snapshot: true\n      do_not_boot: false\n    delay:\n      time: 5m\n    hardware:\n      os_type: linux\n      drives:\n      - image: ubuntu.qc2\n    network:\n      interfaces:\n      - name: IF0\n        vlan: EXP-1\n        address: 192.168.10.2\n        mask: 24\n        gateway: 192.168.10.254\n        proto: static\n        type: ethernet\n      - name: IF1\n        vlan: MGMT\n        address: 172.16.10.2\n        mask: 16\n        proto: static\n        type: ethernet\n      - name: S0\n        vlan: EXT\n        address: 10.0.0.1\n        mask: 24\n        proto: static\n        type: serial\n        udp_port: 8989\n        baud_rate: 9600\n        device: /dev/ttyS0\n  - type: VirtualMachine\n    general:\n      hostname: AD1\n      snapshot: true\n    delay:\n      c2:\n      - hostname: host-00\n        useUUID: false\n    hardware:\n      os_type: windows\n      drives:\n      - image: win-svr-2k8.qc2\n    network:\n      interfaces:\n      - name: IF0\n        vlan: EXP-1\n        address: 192.168.10.250\n        mask: 24\n        gateway: 192.168.10.254\n        proto: static\n        type: ethernet\n      - name: IF1\n        vlan: MGMT\n        address: 172.16.10.3\n        mask: 16\n        proto: static\n        type: ethernet\n  - type: Router\n    labels:\n      ntp-server: \"true\"\n    general:\n      hostname: router-00\n      snapshot: true\n    hardware:\n      os_type: linux\n      drives:\n      - image: vyatta.qc2\n    network:\n      interfaces:\n      - name: IF0\n        vlan: EXP-1\n        address: 192.168.10.254\n        mask: 24\n        proto: static\n        type: ethernet\n        ruleset_in: test\n      - name: IF1\n        vlan: MGMT\n        address: 172.16.10.254\n        mask: 16\n        proto: static\n        type: ethernet\n      rulesets:\n      - name: test\n        default: drop\n        rules:\n        - id: 10\n          action: accept\n          protocol: all\n          source:\n            address: 1.1.1.1\n            port: 53\n</code></pre>"},{"location":"configuration/#scenario","title":"Scenario","text":"<p>The <code>Scenario</code> configuration is used to define and configure one or more <code>phenix</code> apps (default or user) for use with a topology. In this sense, a topology can have one or more scenarios associated with it, but a scenario can only be associated with a single topology.</p>"},{"location":"configuration/#apps","title":"Apps","text":"<p>A <code>phenix</code> app can be applied to an experiment topology using a single configuration, a per-host configuration, or both. Examples could include:</p> <ul> <li>a <code>phenix</code> app that adds a minimega tap to all hosts in the cluster,</li> <li>one that injects the same file into every node in the experiment topology, or</li> <li>one that configures a VPN between two nodes in an experiment using WireGuard.</li> </ul> <p>The first two examples would involve a single configuration, while the last example would use a per-host configuration because (1) only two nodes will be modified, and (2) each of the two nodes will require different configurations (e.g., one will be a WireGuard client and the other a WireGuard server). Each configured app can contain a list of topology nodes to apply the app to, along with custom metadata for the app specific to the topology node.</p>"},{"location":"configuration/#app-configuration-options","title":"App Configuration Options","text":"<ul> <li> <p><code>assetDir</code>: used by apps to generate absolute path to asset files when   relative paths are provided in app metadata. The default is an empty string.</p> </li> <li> <p><code>fromScenario</code>: name of another scenario config to pull this app config from.   This allows for defining complex app configurations in a single base scenario   and referencing it from scenarios included in experiments. The default is an   empty string.</p> </li> <li> <p><code>hosts</code>: a list of per-host configurations to apply to the experiment   topology. The default is <code>nil</code>.</p> <ul> <li> <p><code>hostname</code>: the name of the experiment VM to apply this per-host metadata   to.</p> </li> <li> <p><code>metadata</code>: app metadata to apply to this experiment VM. The default is   <code>nil</code>.</p> </li> </ul> </li> <li> <p><code>metadata</code>: app metadata to apply to this experiment. The default is <code>nil</code>.</p> </li> <li> <p><code>name</code>: the name of the app being configured. There is no default value; one   must be provided.</p> </li> <li> <p><code>runPeriodically</code>: a   Golang duration string   specifying how often to trigger the app's running stage. The default value is   an empty string, which means the app's running stage will not be triggered   periodically.</p> </li> </ul>"},{"location":"configuration/#example_1","title":"Example","text":"<p>The following is an example of a configuration for a scenario named <code>foobar</code>, which can only be applied to an accompanying topology named <code>foobar</code> (while these names are the same in this example, the topology and scenario names do not have to match). Included in this scenario are apps named <code>miniccc-injector</code>, <code>startup</code>, <code>protonuke</code>, and <code>wireguard</code>. Each entry in the list of app hosts includes custom app metadata and the hostname of the topology node to apply the metadata.</p> <pre><code>apiVersion: phenix.sandia.gov/v1\nkind: Scenario\nmetadata:\n  name: foobar\n  annotations:\n    topology: foobar\nspec:\n  apps:\n  - name: miniccc-injector\n    metadata:\n      # files to inject into each node in experiment, based on OS type\n      linux:\n        src: /phenix/injects/miniccc\n        dst: /usr/local/bin/miniccc\n      windows:\n        src: /phenix/injects/miniccc.exe\n        dst: phenix/miniccc.exe\n  - name: startup\n    hosts:\n    - hostname: host-00 # hostname of topology node to apply it to\n      metadata:\n        domain_controller:\n          domain: example.com\n          ip: 10.0.0.1\n          username: admin\n          password: SuperSecretPassword\n  - name: protonuke\n    hosts:\n    - hostname: host-01 # hostname of topology node to apply it to\n      metadata:\n        # protonuke app metadata for this topology node\n        args: -logfile /var/log/protonuke.log -level debug -http -https -smtp -ssh 192.168.100.100\n  - name: wireguard\n    hosts:\n    - hostname: AD1 # hostname of topology node to apply it to\n      metadata:\n        # wireguard app metadata for this topology node\n        infrastructure:\n          private_key: GLlxWJom8cQViGHojqOUShWIZG7IsSX8\n          address: 10.255.255.1/24\n          listen_port: 51820\n        peers:\n          public_key: +joyya2F9g72qbKBtPDn00mIevG1j1OqeN76ylFLsiE=\n          allowed_ips: 10.255.255.10/32\n</code></pre> <p>Note</p> <p>The above example includes an app named <code>startup</code>, which is a ph\u0113nix default app. Meaning, it is possible to configure default ph\u0113nix apps in a scenario configuration, not just user apps.</p> <p>Note</p> <p>See Scorch for additional information on Scenario Orchestration</p>"},{"location":"configuration/#experiment","title":"Experiment","text":"<p><code>Experiment</code> configurations represent the combination of topologies and scenarios to form an experiment (it should be note that an experiments do not require a scenario).</p> <p>Typically experiment configurations are created automatically, but it is possible to create them manually using a configuration file similar to the one shown below. In this case, an experiment named <code>foobar</code> would be created based on an existing topology named <code>foobar</code> and an existing scenario named <code>foobar</code> (note that none of the names are required to match).</p> <pre><code>apiVersion: phenix.sandia.gov/v1\nkind: Experiment\nmetadata:\n  name: foobar\n  annotations:\n    topology: foobar # this is required\n    scenario: foobar # this is optional\n</code></pre> <p>Once created, either manually or automatically, the experiment configuration will be expanded to have the topology and scenario configurations embedded in it, as well as additional details like cluster host schedules for VMs, VLAN ranges, Builder XML, etc. The advantage of embedding the topology and scenario into the experiment is that they can be modified in the experiment without modifying the originals.</p>"},{"location":"configuration/#image","title":"Image","text":"<p>The <code>Image</code> configuration is used to generate VM disk images using a custom version of vmdb2. Representing a disk image in a configuration like this allows for the same disk image to easily be built in different clusters without having to actually move large disk image files.</p> <p>Note</p> <p>The ph\u0113nix image capability will only generation Linux based images. It will not generate Windows disk images.</p> <p>Typically image configurations are created automatically by the <code>phenix image create</code> command, but users can also create them manually using a configuration file similar to the one shown below. This file can then be created in the ph\u0113nix store using the <code>phenix cfg create &lt;path-to-file&gt;</code> command.</p> <pre><code>apiVersion: phenix.sandia.gov/v1\nkind: Image\nmetadata:\n  name: foobar\nspec:\n  format: qcow2\n  mirror: http://us.archive.ubuntu.com/ubuntu/\n  overlay: []\n  packages:\n  - initramfs-tools\n  - net-tools\n  - isc-dhcp-client\n  - openssh-server\n  - init\n  - iputils-ping\n  - vim\n  - less\n  - netbase\n  - curl\n  - ifupdown\n  - dbus\n  - linux-image-generic\n  - linux-headers-generic\n  release: bionic\n  size: 5G\n  variant: minbase\n  scripts:\n    POSTBUILD_APT_CLEANUP: |\n      apt clean || apt-get clean || echo \"unable to clean apt cache\"\n    POSTBUILD_NO_ROOT_PASSWD: |\n      sed -i 's/nullok_secure/nullok/' /etc/pam.d/common-auth\n      sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config\n      sed -i 's/#PermitEmptyPasswords no/PermitEmptyPasswords yes/' /etc/ssh/sshd_config\n      sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config\n      sed -i 's/PermitEmptyPasswords no/PermitEmptyPasswords yes/' /etc/ssh/sshd_config\n      passwd -d root\n</code></pre> <p>Note</p> <p>If no overlay is used in the image configuration, an empty array must be provided</p>"},{"location":"configuration/#user","title":"User","text":"<p>The <code>User</code> configuration tracks ph\u0113nix UI user settings (e.g., username, password, and RBAC permissions). Typically user configurations are created automatically when a UI admin creates a new user via the UI, but they can also be created manually using a configuration file similar to the one shown below.</p> <pre><code>apiVersion: phenix.sandia.gov/v1\nkind: User\nmetadata:\n  name: admin@foo.com\nspec:\n  username: admin@foo.com\n  first_name: Admin\n  last_name: Istrator\n  password: ****************\n  rbac:\n    roleName: Global Admin\n    policies:\n    - resourceNames:\n      - '*'\n      resources:\n      - '*'\n      - '*/*'\n      verbs:\n      - '*'\n    - resourceNames:\n      - admin@foo.com\n      resources:\n      - users\n      verbs:\n      - get\n</code></pre>"},{"location":"configuration/#role","title":"Role","text":"<p>The <code>Role</code> configuration is used to represent a named set of RBAC permissions that represent a user's role in the UI. When a new user is created, the role that user should have is specified, and using that role name the appropriate RBAC permissions are copied from the role configuration into the user configuration.</p> <p>There are six (6) default role configurations that get created automatically, and are described here. An example role configuration is shown below for completeness.</p> <pre><code>apiVersion: phenix.sandia.gov/v1\nkind: Role\nmetadata:\n  name: global-admin\nspec:\n  roleName: Global Admin\n  policies:\n  - resourceNames:\n    - '*'\n    resources:\n    - '*'\n    - '*/*'\n    verbs:\n    - '*'\n</code></pre>"},{"location":"configuration/#web-ui","title":"Web-UI","text":""},{"location":"configuration/#config-table","title":"Config Table","text":"<p>The <code>Configs</code> component will initially load with a table presenting all the available configuration files. It is possible to filter in two ways:</p> <ol> <li>There is a pull-down selector, which will allow filtering on a specific    <code>Kind</code> of config; and,</li> </ol> <p></p> <ol> <li>A filter field will allow filtering on <code>Name</code> (if you have filtered on    <code>Kind</code>, it will be limited to that kind of config).</li> </ol> <p></p> <p>Clicking on the <code>X</code> next to the <code>Find a Config</code> field will reset both filters.</p>"},{"location":"configuration/#view-a-config","title":"View a Config","text":"<p>There are two ways to view a specific config:</p> <ol> <li>Clicking the name of the config entry will open a modal to view the config.    It is possible to select text and copy from this modal. However, it is not    possible to edit the config directly in this view. Instead, there is an    <code>Edit Config</code> button, which will open an editor. It is also possible to    download a copy of the config.</li> </ol> <p></p> <ol> <li>Selecting the <code>Edit</code> button for a given config will open the editor window.    It is possible to edit the config in this window and save the update to the    ph\u0113nix store. The config will be validated against the schema, and if    invalid, an error will be presented.</li> </ol> <p></p>"},{"location":"configuration/#create-a-config","title":"Create a Config","text":"<p>There are two ways to create a new config:</p> <ol> <li>Selecting the <code>Upload</code> button located to the far right of the search field    will allow you to upload a file from disk. It is possible to drag and drop in    the upload modal or click the upload icon to open a file browser.</li> </ol> <p>Note</p> <p>Only files with the extensions <code>.yml</code>, <code>.yaml</code>, and <code>.json</code> will be allowed. Any file uploaded will be validated against the schema for a given kind of config, and if invalid, an error will be presented.</p> <p></p> <ol> <li>Clicking the <code>+</code> button next to the search field will present an editor    window where it is possible to create a new file in place. A basic template    is provided based on the kind of config selected (see next section for    documentation on the editor window features). Once editing a config is    completed, clicking the <code>Create</code> button will post it server-side where it    will be validated, similar to file upload. If invalid, an error will be    presented.</li> </ol> <p></p>"},{"location":"configuration/#editor-window","title":"Editor Window","text":"<p>The editor window allows direct editing of an existing or new config file.</p> <ul> <li> <p>It is possible to edit a file as YAML or JSON by selecting the relevant radio   button under <code>File Format</code>.</p> </li> <li> <p>It is also possible to set keybindings to the Vim editor by enabling them with   the sliding selector under <code>Vim Keybindings</code>.</p> </li> </ul> <p></p>"},{"location":"configuration/#new-config","title":"New Config","text":"<p>The editor window for creating a new config will allow editing the filename in a text field to the left or within the config editor directly. Similarly, use the pull-down selector to the left to select the kind of config or within the config editor.</p> <p></p> <p>Selecting the <code>Create</code> button will post the new config server-side for validation and addition to the store. Choosing the <code>Exit</code> button will leave the editor window; nothing will be saved.</p>"},{"location":"configuration/#existing-config","title":"Existing Config","text":"<p>Changing the name in an existing config is only available through the editor window.</p> <p></p> <p>Selecting the <code>Save</code> button will post any updates server-side for validation and addition to the store. Selecting the <code>Exit</code> button will leave the editor window; nothing will be saved.</p>"},{"location":"configuration/#delete-a-config","title":"Delete a Config","text":"<p>Selecting the delete icon will delete a config. A confirmation dialog will be presented to confirm the selection. Once the config is deleted, it cannot be restored to the store. If an experiment config is deleted, the corresponding experiment will not longer be presented in the <code>Experiments</code> tab.</p> <p></p>"},{"location":"configuration/#builder","title":"Builder","text":"<p>The Builder app is an external app that allows users to generate either topology or experiment configuration using a graphical interface. It is based on the <code>minibuilder</code> app in <code>minimega</code>. Users can access the Builder app via the <code>Builder</code> tab in the ph\u0113nix UI.</p>"},{"location":"configuration/#creating-or-editing-a-topology","title":"Creating or Editing a Topology","text":"<p>When Builder opens, it does so in a new configuration. If a user wanted to open an existing configuration, they are available in the File menu through the Import from ph\u0113nix or Import from Disk selections.</p> <p>A user can add VM hosts or networking components by selecting the relevant image on the left side of the Builder canvas.</p> <p></p> <p>Each time a configuration is saved to ph\u0113nix, it is available to select from Import from ph\u0113nix in the File menu. A configuration created in Builder can only be edited while in the Builder app. There are two options for editing an existing configuration created in Builder.</p> <p></p> <ol> <li> <p>Select Import from ph\u0113nix in Builder \u2014 make any changes and then add to    ph\u0113nix with a new name</p> </li> <li> <p>Select Import from ph\u0113nix in Builder \u2014 make any changes and then add to    ph\u0113nix with the same name; this will overwrite the configuration that was    selected to import</p> </li> </ol> <p>Note</p> <p>Any hosts added to a topology will not have a drive image name; this is a requirement and will need to be included in each node added to the Builder canvas.</p> <p></p> <p>Other values will be auto-generated but can be customized by clicking on a target node and making changes in the dialogue presented in the Builder UI. It is worth noting that a user can set a single node value and then copy and paste that node multiple times; the customized values will be extended to each node that is pasted in the Builder canvas.</p> <p>While scenarios are not a part of the Builder environment, a user can add them to a topology. When a user selects Save to ph\u0113nix, a pulldown will be presented with available scenarios from the ph\u0113nix store.</p> <p></p> <p>When a scenario is selected, Builder will write the topology configuration to the ph\u0113nix store and an experiment configuration. When a scenario is not specified, the Builder app will save the topology configuration only. The user will then need to create an experiment in the ph\u0113nix UI.</p>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>Ph\u0113nix supports environment variables in its configuration files. On creation of a new ph\u0113nix config, any environment variable placeholders found in the config are replaced with their corresponding values. Placeholders can be in the format <code>${VAR}</code> or <code>${VAR:default}</code>, where <code>VAR</code> is the environment variable name, and <code>default</code> is an optional default value to use if the variable is not set. If the environment variable is not found and no default is provided, the placeholder is replaced with an empty string.</p> <p>Example config before parsing environment variables:</p> <pre><code>  - name: foobar\n    metadata:\n      baz:\n        ip: ${HOST:localhost}\n</code></pre> <p>After parsing with <code>HOST=172.1.3.37</code>:</p> <pre><code>  - name: foobar\n    metadata:\n      baz:\n        ip: 172.1.3.37\n</code></pre> <p>Or if <code>HOST</code> env variable isn't found, the default is used:</p> <pre><code>  - name: foobar\n    metadata:\n      baz:\n        ip: localhost\n</code></pre>"},{"location":"configuration/#environment-variables-using-docker","title":"Environment variables using Docker","text":"<p>If ph\u0113nix is running in a docker container (or docker compose), environment variables can be passed into the compose file and/or via args in any CLI calls to ph\u0113nix, e.g.</p> <pre><code>    environment:\n      HOST: ${HOST}\n</code></pre> <p>or</p> <pre><code>docker exec -it -e BRANCH_NAME=foobar phenix phenix exp create foobar -t topo -s scenario\n</code></pre>"},{"location":"experiments/","title":"Experiments","text":""},{"location":"experiments/#listing-experiments","title":"Listing Experiments","text":""},{"location":"experiments/#from-the-web-ui","title":"From the Web-UI","text":"<p>Click on the <code>Experiments</code> tab. This will display all available experiments that the user has access to view or edit.</p>"},{"location":"experiments/#from-the-command-line-binary","title":"From the Command Line Binary","text":"<p>This will display a list of all available experiments: it is run as a <code>root</code> user.</p> <p><pre><code>$&gt; phenix exp list\n</code></pre> </p>"},{"location":"experiments/#starting-stopping-experiments","title":"Starting / Stopping Experiments","text":""},{"location":"experiments/#from-the-web-ui_1","title":"From the Web-UI","text":"<p>Clicking the <code>stopped</code> button will start the experiment; similarly the <code>started</code> button will stop the experiment. A progress bar is used to update the progress of starting an experiment. During the update to the experiment -- starting or stopping -- it will not be accessible or available to delete. </p>"},{"location":"experiments/#from-the-command-line-binary_1","title":"From the Command Line Binary","text":"<p><pre><code>$&gt; phenix exp start &lt;experiment name&gt;\n</code></pre> Or ... <pre><code>$&gt; phenix exp stop &lt;experiment name&gt;\n</code></pre> Or ... <pre><code>$&gt; phenix exp restart &lt;experiment name&gt;\n</code></pre></p> <p>Optionally, you can use the <code>--dry-run</code> flag to do everything except call out to minimega.</p> <p>The <code>phenix exp --help</code> command will output:</p> <pre><code>Experiment management\n\nUsage:\n  phenix experiment [flags]\n  phenix experiment [command]\n\nAliases:\n  experiment, exp\n\nAvailable Commands:\n  apps        List of available apps to assign an experiment\n  create      Create an experiment\n  delete      Delete an experiment\n  list        Display a table of available experiments\n  restart     Start an experiment\n  schedule    Schedule an experiment\n  schedulers  List of available schedulers to assign an experiment\n  start       Start an experiment\n  stop        Stop an experiment\n\nFlags:\n  -h, --help   help for experiment\n\nGlobal Flags:\n      --base-dir.minimega string   base minimega directory (default \"/tmp/minimega\")\n      --base-dir.phenix string     base phenix directory (default \"/phenix\")\n      --hostname-suffixes string   hostname suffixes to strip\n      --log.error-file string      log fatal errors to file (default \"/root/.phenix.err\")\n      --log.error-stderr           log fatal errors to STDERR\n      --store.endpoint string      endpoint for storage service (default \"bolt:///root/.phenix.bdb\")\n\nUse \"phenix experiment [command] --help\" for more information about a command.\n</code></pre>"},{"location":"experiments/#create-a-new-experiment","title":"Create a New Experiment","text":""},{"location":"experiments/#from-the-web-ui_2","title":"From the Web-UI","text":"<p>Click the <code>+</code> button to the right of the filter field. </p> <p></p> <p>Enter <code>Experiment Name</code> and <code>Experiment Topology</code>, the remaining selection are optional. In this example, <code>bennu</code> is an example topology and is not included by default. You will need to create your own topology(ies).</p>"},{"location":"experiments/#from-the-command-line-binary_2","title":"From the Command Line Binary","text":"<p>Three options are available from the command line. The only requirements are for an experiment and topology name; scenario and base directory are optional.</p> <pre><code>$&gt; phenix experiment create &lt;experiment name&gt; -t &lt;topology name&gt;\n$&gt; phenix experiment create &lt;experiment name&gt; -t &lt;topology name&gt; -s &lt;scenario name&gt;\n$&gt; phenix experiment create &lt;experiment name&gt; -t &lt;topology name&gt; -s &lt;scenario name&gt; -d &lt;/path/to/dir/&gt;`\n</code></pre> <p>The <code>phenix exp create --help</code> command will output:</p> <pre><code>Create an experiment\n\n  Used to create an experiment from an existing configuration; can be a \n  topology, or topology and scenario. (Optional are the arguments for scenario \n  or base directory.)\n\nUsage:\n  phenix experiment create &lt;experiment name&gt; [flags]\n\nExamples:\n\n  phenix experiment create &lt;experiment name&gt; -t &lt;topology name&gt;\n  phenix experiment create &lt;experiment name&gt; -t &lt;topology name&gt; -s &lt;scenario name&gt;\n  phenix experiment create &lt;experiment name&gt; -t &lt;topology name&gt; -s &lt;scenario name&gt; -d &lt;/path/to/dir/&gt;\n\nFlags:\n  -d, --base-dir string   Base directory to use for experiment (optional)\n  -h, --help              help for create\n  -s, --scenario string   Name of an existing scenario to use (optional)\n  -t, --topology string   Name of an existing topology to use\n\nGlobal Flags:\n      --base-dir.minimega string   base minimega directory (default \"/tmp/minimega\")\n      --base-dir.phenix string     base phenix directory (default \"/phenix\")\n      --hostname-suffixes string   hostname suffixes to strip\n      --log.error-file string      log fatal errors to file (default \"/root/.phenix.err\")\n      --log.error-stderr           log fatal errors to STDERR\n      --store.endpoint string      endpoint for storage service (default \"bolt:///root/.phenix.bdb\")\n</code></pre>"},{"location":"experiments/#scheduling-an-experiment","title":"Scheduling an Experiment","text":""},{"location":"experiments/#from-web-ui","title":"From Web-UI","text":"<p>The experiment must be stopped; click on the experiment name to enter the Stopped Experiment component. Click on the hamburger menu to the right of the filter field and start button to select a desired schedule.</p> <p></p>"},{"location":"experiments/#from-the-command-line-binary_3","title":"From the Command Line Binary","text":"<p>The list of available schedules can be found by running the folowing command.</p> <pre><code>$&gt; phenix exp schedulers\n</code></pre> <p>Then apply the desired schedule with the following command.</p> <pre><code>$&gt; phenix experiment schedule &lt;experiment name&gt; &lt;algorithm&gt;\n</code></pre>"},{"location":"image/","title":"Virtual Disk Images Management","text":"<p>This is only available from the command line binary at this time.</p>"},{"location":"image/#listing-disk-images","title":"Listing disk images","text":"<pre><code>phenix image list\n</code></pre>"},{"location":"image/#creating-a-disk-image","title":"Creating a disk image","text":"<p>The <code>vmdb2</code> utility is required -- in path -- to create the disk images. This utility is included with the phenix Docker image.</p> <pre><code>phenix image create &lt;image name&gt;\n</code></pre> <p>The <code>phenix image create --help</code> will output:</p> <pre><code>Create a disk image configuration\n\n  Used to create a virtual disk image configuration from which to build\n  an image\n\nUsage:\n  phenix image create &lt;image name&gt; [flags]\n\nExamples:\n\n  phenix image create &lt;image name&gt;\n  phenix image create --size 2G --variant mingui --release xenial --format qcow2 --compress --overlays foobar --packages foo --scripts bar &lt;image name&gt;\n\nFlags:\n  -c, --compress                    Compress image after creation (does not apply to raw image)\n  -d, --debootstrap-append string   Additional arguments to debootstrap \"(default: --components=main,restricted,universe,multiverse)\"\n  -f, --format string               Format of disk image (default \"raw\")\n  -h, --help                        help for create\n  -m, --mirror string               Debootstrap mirror (must match release) (default \"http://us.archive.ubuntu.com/ubuntu/\")\n  -O, --overlays string             List of overlay names (include full path; separated by comma)\n  -P, --packages string             List of packages to include in addition to those provided by variant (separated by comma)\n  -R, --ramdisk                     Create a kernel/initrd pair in addition to a disk image\n  -r, --release string              OS release codename (default \"bionic\")\n  -T, --scripts string              List of scripts to include in addition to the defaults (include full path; separated by comma)\n  -s, --size string                 Image size to use (default \"5G\")\n  -v, --variant string              Image variant to use (default \"minbase\")\n\nGlobal Flags:\n      --base-dir.minimega string   base minimega directory (default \"/tmp/minimega\")\n      --base-dir.phenix string     base phenix directory (default \"/phenix\")\n      --hostname-suffixes string   hostname suffixes to strip\n      --log.error-file string      log fatal errors to file (default \"/var/log/phenix/error.log\")\n      --log.error-stderr           log fatal errors to STDERR\n      --store.endpoint string      endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\")\n</code></pre> <p>The <code>vmdb2</code> configuration file can be read by running the following command:</p> <pre><code>phenix cfg get image/&lt;image name&gt;\n</code></pre>"},{"location":"image/#building-a-disk-image","title":"Building a disk image","text":"<p>Building a disk image requires an existing configuration in the store (i.e., the <code>create</code> command should be run first to create a configuration); running <code>phenix image build --help</code> will output:</p> <pre><code>Build a virtual disk image\n\n  Used to build a new virtual disk using an exisitng configuration; vmdb2 must\n  be in path.\n\nUsage:\n  phenix image build &lt;configuration name&gt; [flags]\n\nExamples:\n\n  phenix image build &lt;configuration name&gt;\n  phenix image build --very-very-verbose --output &lt;/path/to/dir/&gt;\n\nFlags:\n  -c, --cache               Cache rootfs as tar archive\n      --dry-run             Do everything but actually call out to vmdb2\n  -h, --help                help for build\n  -o, --output string       Specify the output directory for the disk image to be saved to\n  -v, --verbose             Enable verbose output\n  -w, --very-verbose        Enable very verbose output\n  -x, --very-very-verbose   Enable very verbose output plus additional verbose output from debootstrap\n\nGlobal Flags:\n      --base-dir.minimega string   base minimega directory (default \"/tmp/minimega\")\n      --base-dir.phenix string     base phenix directory (default \"/phenix\")\n      --hostname-suffixes string   hostname suffixes to strip\n      --log.error-file string      log fatal errors to file (default \"/var/log/phenix/error.log\")\n      --log.error-stderr           log fatal errors to STDERR\n      --store.endpoint string      endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\")\n</code></pre>"},{"location":"image/#miscellaneous-commands","title":"Miscellaneous Commands","text":""},{"location":"image/#append","title":"append","text":"<p>The disk image management tool will allow you to add packages, overlays, and scripts to exisitng configurations using the <code>append</code> command. Command usage is:</p> <pre><code>phenix image append &lt;configuration name&gt; [flags]\n</code></pre> <p>Flags are for the overlays, packages, and scripts that you want to append.</p>"},{"location":"image/#create-from","title":"create-from","text":"<p>Run this command if you have an existing configuration that you would like to use as the base to create a new configuration from. The usage involves referencing the existing configuration, the new configuration name, and then additional packages, overlays, and scripts.</p> <pre><code>phenix image create-from &lt;existing configuration&gt; &lt;new configuration&gt; [flags]\n</code></pre> <p>Flags are for the overlays, packages, and scripts that you want to add to the new configuration.</p>"},{"location":"image/#delete","title":"delete","text":"<pre><code>phenix image delete &lt;image name&gt;\n</code></pre> <p>An alternative could be to use the configuration management tool.</p> <pre><code>phenix cfg delete image/&lt;image name&gt;\n</code></pre>"},{"location":"image/#remove","title":"remove","text":"<p>The <code>remove</code> command will allow you to remove any packages, overlays, and scripts from an existing image configuration.</p> <pre><code>phenix image remove &lt;configuration name&gt; [flags]\n</code></pre> <p>Flags are for the overlays, packages, and scripts that you want to remove.</p>"},{"location":"image/#update","title":"update","text":"<p>This <code>update</code> command is used to update the script on an existing image configuration. The path to a script is tracked in the code. The image configuration gets updated with the script in the path; if no changes were made no harm. If the path no longer exists, phenix will leave the configuration alone.</p> <pre><code>phenix image update &lt;configuration name&gt;\n</code></pre>"},{"location":"image/#kali-image","title":"Kali Image","text":"<p>The Docker image for phenix includes everything needed to build a Kali image. If phenix is installed locally, the following will be needed to create and build a Kali image.</p> <p>To build a Kali release on a non-Kali (but still Debian-based) operating system, the following steps must be taken to prepare the host (Debian-based) OS first. These steps are based on the official Kali documentation located at:</p> <p>https://www.kali.org/tutorials/build-kali-with-live-build-on-debian-based-systems/.</p> <ol> <li>Download and install the latest version of the Kali archive keyring package.    At time of writing, the latest version was 2020.2.</li> </ol> <pre><code>wget http://http.kali.org/kali/pool/main/k/kali-archive-keyring/kali-archive-keyring_2020.2_all.deb\nsudo dpkg -i kali-archive-keyring_2020.2_all.deb\n</code></pre> <ol> <li>Next, create the <code>debootstrap</code> build script for Kali, based entirely off the    existing Debian Sid build script. Note that the following commands will    likely need to be run as root.</li> </ol> <pre><code>cd /usr/share/debootstrap/scripts\nsed -e \"s/debian-archive-keyring.gpg/kali-archive-keyring.gpg/g\" sid &gt; kali\nln -s kali kali-rolling\n</code></pre> <p>At this point, you should be able to build a Kali release with <code>phenix image</code>.</p>"},{"location":"kb/","title":"Knowledge Base","text":""},{"location":"kb/#article-ex-sc-upg-01","title":"Article EX-SC-UPG-01","text":"<p>The phenix Scenario configuration has been upgraded to v2 to get rid of the distinction between experiment apps and host apps. While the phenix app takes care of upgrading existing v1 scenarios to v2 when viewing, embedding into an experiment, etc., it does not automatically upgrade embedded scenarios in existing experiment configs.</p> <p>Users might encounter the following error message when trying to do anything with experiments that were created with a v1 scenario config:</p> <pre><code>'scenario.apps': source data must be an array or slice, got map\n</code></pre> <p>There are two ways to overcome this error:</p> <ol> <li>Delete the experiment using the <code>config delete</code> subcommand and recreate it    with the <code>experiment create</code> command; or</li> <li>Edit the experiment using the <code>config edit</code> subcommand. If the experiment    is running, use the <code>--force</code> flag with <code>config edit</code>.</li> </ol> <p>If you choose to edit an existing experiment rather than deleting and recreating, all you need to do is delete the <code>experiment</code> and <code>host</code> keys in the <code>scenario.apps</code> section of the experiment spec and make <code>scenario.apps</code> a list of apps instead of a map.</p> <p>For example, say you have an experiment whose <code>scenario.apps</code> section of the config looks like the following when you go to edit it:</p> <pre><code>scenario:\n  apps:\n    experiment:\n    - name: test-user-app\n      metadata: {}\n    host:\n    - name: protonuke\n      hosts:\n      - hostname: host-00\n        metadata:\n          args: -logfile /var/log/protonuke.log -level debug -http -https -smtp -ssh 192.168.100.100\n</code></pre> <p>After editing, the scenario section should look like the following:</p> <pre><code>scenario:\n  apps:\n  - name: test-user-app\n    metadata: {}\n  - name: protonuke\n    hosts:\n    - hostname: host-00\n      metadata:\n        args: -logfile /var/log/protonuke.log -level debug -http -https -smtp -ssh 192.168.100.100\n</code></pre>"},{"location":"netflow/","title":"Experiment Netflow","text":"<p>The minimega platform supports netflow capture, wherein flows through an Open vSwitch bridge can be parsed into an ASCII format and forwarded to a remote endpoint for additional consumption.</p> <p>ph\u0113nix extends this capability by making the minimega netflow ASCII format available for streaming over WebSockets for experiments. The only requirement for enabling netflow for an experiment is that the experiment be configured to use a bridge name that is not the default <code>phenix</code> bridge. This can be done via the UI by expanding the <code>Options</code> section when creating a new experiment and providing the <code>Default Bridge Name</code> setting.</p> <p></p> <p>This can also be done via the CLI by providing the <code>--default-bridge, -b</code> option when using the <code>phenix exp create</code> subcommand.</p> <p>Warning</p> <p>As mentioned above, the experiment netflow capability will not work if a default bridge name is not explicitly specified for an experiment. This is to prevent network flows across multiple experiments from being captured.</p>"},{"location":"netflow/#usage","title":"Usage","text":"<p>Running experiments will have a green network icon to the left of the VM search box that, when clicked, will start netflow capture for the non-default bridge the experiment is configured to use for all VM network interfaces.</p> <p></p> <p>Once enabled, the icon will turn red (to signify it can be stopped), and a new <code>Netflow</code> tab will appear next to the <code>VMs</code> and <code>Files</code> tabs for the running experiment. This tab will be updated with ASCII netflow data from minimega as it streams in.</p> <p></p> <p>To stop netflow capture for the experiment, click the red network icon.</p>"},{"location":"schema/","title":"Configuration File Schemas","text":"<p>The following schemas are all represented using the <code>OpenAPIv3</code> format. The complete schema is described here.</p>"},{"location":"schema/#topology-schema","title":"Topology Schema","text":"<p>The <code>topology</code> schema is largely comprised of nodes, described here.</p> <pre><code>Topology:\n  type: object\n  title: Demo Topology\n  required:\n  - nodes\n  properties:\n    nodes:\n      type: array\n      title: Nodes\n      items:\n        oneOf:\n        - $ref: '#/components/schemas/minimega_node'\n        - $ref: '#/components/schemas/external_node'\n</code></pre>"},{"location":"schema/#scenario-schema","title":"Scenario Schema","text":"<pre><code>Scenario:\n  type: object\n  nullable: true\n  required:\n  - apps\n  properties:\n    apps:\n      type: array\n      nullable: true\n      items:\n        type: object\n        required:\n        - name\n        properties:\n          name:\n            type: string\n            example: example-app\n          assetDir:\n            type: string\n            example: /phenix/topologies/example-topo/assets\n          metadata:\n            type: object\n            nullable: true\n            additionalProperties: true\n            example:\n              setting0: true\n              setting1: 42\n              setting2: universe key\n          hosts:\n            type: array\n            items:\n              type: object\n              required:\n              - hostname\n              properties:\n                hostname:\n                  type: string\n                  example: example-host\n                metadata:\n                  type: object\n                  nullable: true\n                  additionalProperties: true\n                  example:\n                    setting0: true\n                    setting1: 42\n                    setting2: universe key\n</code></pre>"},{"location":"schema/#experiment-schema","title":"Experiment Schema","text":"<pre><code>Experiment:\n  type: object\n  required:\n  - topology\n  properties:\n    topology:\n      $ref: \"#/components/schemas/Topology\"\n    scenario:\n      $ref: \"#/components/schemas/Scenario\"\n    baseDir:\n      type: string\n      example: /phenix/topologies/example-topo\n    experimentName:\n      type: string\n      example: example-exp\n      readOnly: true\n    vlans:\n      type: object\n      nullable: true\n      properties:\n        aliases:\n          type: object\n          nullable: true\n          additionalProperties:\n            type: integer\n          example:\n            MGMT: 200\n        min:\n          type: integer\n        max:\n          type: integer\n    schedule:\n      type: object\n      nullable: true\n      additionalProperties:\n        type: string\n      example:\n        ADServer: compute1\n</code></pre>"},{"location":"schema/#image-schema","title":"Image Schema","text":"<pre><code>Image:\n  type: object\n  required:\n  - format\n  - mirror\n  - release\n  - size\n  - variant\n  properties:\n    compress:\n      type: boolean\n      default: false\n      example: false\n    deb_append:\n      type: string\n      example: --components=main,restricted\n    format:\n      type: string\n      example: qcow2\n    mirror:\n      type: string\n      example: http://us.archive.ubuntu.com/ubuntu/\n    overlays:\n      type: array\n      nullable: true\n      items:\n        type: string\n      example:\n      - /phenix/vmdb/overlays/example-overlay\n    packages:\n      type: array\n      nullable: true\n      items:\n        type: string\n      example:\n      - isc-dhcp-client\n      - openssh-server\n    ramdisk:\n      type: boolean\n      default: false\n      example: false\n    release:\n      type: string\n      example: focal\n    script_order:\n      type: array\n      nullable: true\n      items:\n        type: string\n      example:\n      - POSTBUILD_APT_CLEANUP\n    scripts:\n      type: object\n      nullable: true\n      additionalProperties:\n        type: string\n      example:\n        POSTBUILD_APT_CLEANUP: |\n          apt clean || apt-get clean || echo \"unable to clean apt cache\"\n    size:\n      type: string\n      example: 10G\n    variant:\n      type: string\n      example: minbase\n</code></pre>"},{"location":"schema/#user-schema","title":"User Schema","text":"<pre><code>User:\n  type: object\n  required:\n  - first_name\n  - last_name\n  - username\n  properties:\n    first_name:\n      type: string\n      example: John\n    last_name:\n      type: string\n      example: Doe\n    password:\n      type: string\n      example: '&lt;encrypted password&gt;'\n      readOnly: true\n    rbac:\n      allOf:\n      - $ref: \"#/components/schemas/Role\"\n      readOnly: true\n    username:\n      type: string\n      example: johndoe@example.com\n</code></pre>"},{"location":"schema/#role-schema","title":"Role Schema","text":"<pre><code>Role:\n  type: object\n  required:\n  - policies\n  - roleName\n  properties:\n    policies:\n      type: array\n      items:\n        type: object\n        properties:\n          resources:\n            type: array\n            items:\n              type: string\n          resourceNames:\n            type: array\n            items:\n              type: string\n          verbs:\n            type: array\n            items:\n              type: string\n      example:\n      - resources:\n        - experiments\n        - experiments/*\n        resourceNames:\n        - '*'\n        verbs:\n        - list\n        - get\n    roleName:\n      type: string\n      example: Example Role\n</code></pre>"},{"location":"schema/#node-schemas","title":"Node Schemas","text":""},{"location":"schema/#minimega_node-schema","title":"<code>minimega_node</code> Schema","text":"<p>The <code>minimega_node</code> schema contains references to the <code>interface</code> schema described here.</p> <pre><code>minimega_node:\n  type: object\n  required:\n  - type\n  - general\n  - hardware\n  properties:\n    type:\n      type: string\n      default: VirtualMachine\n      example: VirtualMachine\n    general:\n      type: object\n      required:\n      - hostname\n      properties:\n        hostname:\n          type: string\n          example: ADServer\n        description:\n          type: string\n          example: Active Directory Server\n        vm_type:\n          type: string\n          enum:\n          - kvm\n          - container\n          - \"\"\n          default: kvm\n          example: kvm\n        snapshot:\n          type: boolean\n          default: false\n          example: false\n          nullable: true\n        do_not_boot:\n          type: boolean\n          default: false\n          example: false\n          nullable: true\n    hardware:\n      type: object\n      required:\n      - os_type\n      - drives\n      properties:\n        cpu:\n          type: string\n          default: Broadwell\n          example: Broadwell\n        vcpus:\n          oneOf:\n          - type: integer\n          - type: string\n          default: 1\n          example: 4\n        memory:\n          oneOf:\n          - type: integer\n          - type: string\n          default: 1024\n          example: 8192\n        os_type:\n          type: string\n          enum:\n          - centos\n          - linux\n          - minirouter\n          - rhel\n          - vyatta\n          - vyos\n          - windows\n          - other\n          default: linux\n          example: windows\n        drives:\n          type: array\n          minItems: 1\n          items:\n            type: object\n            required:\n            - image\n            properties:\n              image:\n                type: string\n                minLength: 1\n                example: ubuntu.qc2\n              interface:\n                type: string\n                enum:\n                - ahci\n                - ide\n                - scsi\n                - sd\n                - mtd\n                - floppy\n                - pflash\n                - virtio\n                - \"\"\n                default: ide\n                example: ide\n              cache_mode:\n                type: string\n                enum:\n                - none\n                - writeback\n                - unsafe\n                - directsync\n                - writethrough\n                - \"\"\n                default: writeback\n                example: writeback\n              inject_partition:\n                type: integer\n                default: 1\n                example: 2\n                nullable: true\n    network:\n      type: object\n      nullable: true\n      required:\n      - interfaces\n      properties:\n        interfaces:\n          type: array\n          nullable: true\n          items:\n            type: object\n            oneOf:\n            - $ref: '#/components/schemas/static_iface'\n            - $ref: '#/components/schemas/dhcp_iface'\n            - $ref: '#/components/schemas/serial_iface'\n        routes:\n          type: array\n          nullable: true\n          items:\n            type: object\n            required:\n            - destination\n            - next\n            properties:\n              destination:\n                type: string\n                example: 192.168.0.0/24\n              next:\n                type: string\n                example: 192.168.1.254\n              cost:\n                type: integer\n                default: 1\n                example: 1\n                nullable: true\n        ospf:\n          type: object\n          nullable: true\n          required:\n          - router_id\n          - areas\n          properties:\n            router_id:\n              type: string\n              example: 0.0.0.1\n            areas:\n              type: array\n              items:\n                type: object\n                required:\n                - area_id\n                - area_networks\n                properties:\n                  area_id:\n                    type: integer\n                    example: 1\n                    default: 1\n                  area_networks:\n                    type: array\n                    items:\n                      type: object\n                      required:\n                      - network\n                      properties:\n                        network:\n                          type: string\n                          example: 10.1.25.0/24\n        rulesets:\n          type: array\n          nullable: true\n          items:\n            type: object\n            required:\n            - name\n            - default\n            - rules\n            properties:\n              name:\n                type: string\n                example: OutToDMZ\n              description:\n                type: string\n                example: From Corp to the DMZ network\n              default:\n                type: string\n                enum:\n                - accept\n                - drop\n                - reject\n                example: drop\n              rules:\n                type: array\n                items:\n                  type: object\n                  required:\n                  - id\n                  - action\n                  - protocol\n                  properties:\n                    id:\n                      type: integer\n                      example: 10\n                    description:\n                      type: string\n                      example: Allow UDP 10.1.26.80 ==&gt; 10.2.25.0/24:123\n                    action:\n                      type: string\n                      enum:\n                      - accept\n                      - drop\n                      - reject\n                      example: accept\n                    protocol:\n                      type: string\n                      enum:\n                      - tcp\n                      - udp\n                      - tcp_udp\n                      - icmp\n                      - esp\n                      - ah\n                      - all\n                      default: tcp\n                      example: tcp\n                    source:\n                      type: object\n                      nullable: true\n                      required:\n                      - address\n                      properties:\n                        address:\n                          type: string\n                          example: 10.1.24.60\n                        port:\n                          type: integer\n                          example: 3389\n                    destination:\n                      type: object\n                      nullable: true\n                      required:\n                      - address\n                      properties:\n                        address:\n                          type: string\n                          example: 10.1.24.60\n                        port:\n                          type: integer\n                          example: 3389\n    injections:\n      type: array\n      nullable: true\n      items:\n        type: object\n        required:\n        - src\n        - dst\n        properties:\n          src:\n            type: string\n            example: foo.xml\n          dst:\n            type: string\n            example: /etc/phenix/foo.xml\n          description:\n            type: string\n            example: phenix config file\n          permissions:\n            type: string\n            example: '0664'\n    delay:\n      type: object\n      nullable: true\n      properties:\n        timer:\n          type: string\n          example: 5m\n        user:\n          type: boolean\n        c2:\n          type: array\n          nullable: true\n          items:\n            type: object\n            properties:\n              hostname:\n                type: string\n              useUUID:\n                type: boolean\n    advanced:\n      type: object\n      nullable: true\n      additionalProperties:\n        type: string\n    commands:\n      type: array\n      nullable: true\n      items:\n        type: string\n      example:\n      - exec df -h\n</code></pre>"},{"location":"schema/#external_node-schema","title":"<code>external_node</code> Schema","text":"<pre><code>external_node:\n  type: object\n  required:\n  - external\n  - type\n  - general\n  properties:\n    external:\n      type: boolean\n    type:\n      type: string\n      default: HIL\n      example: HIL\n    general:\n      type: object\n      required:\n      - hostname\n      properties:\n        hostname:\n          type: string\n          example: ADServer\n        description:\n          type: string\n          example: Active Directory Server\n        vm_type:\n          type: string\n          enum:\n          - vm\n          - container\n          - \"\"\n          default: vm\n          example: vm\n    hardware:\n      type: object\n      nullable: true\n      required:\n      - os_type\n      properties:\n        cpu:\n          type: string\n          default: Broadwell\n          example: Broadwell\n        vcpus:\n          oneOf:\n          - type: integer\n          - type: string\n          default: 1\n          example: 4\n        memory:\n          oneOf:\n          - type: integer\n          - type: string\n          default: 1024\n          example: 8192\n        os_type:\n          type: string\n          default: linux\n          example: windows\n    network:\n      type: object\n      nullable: true\n      required:\n      - interfaces\n      properties:\n        interfaces:\n          type: array\n          items:\n            type: object\n            required:\n            - name\n            properties:\n              name:\n                type: string\n                example: eth0\n              proto:\n                type: string\n                enum:\n                - static\n                - dhcp\n                - manual\n                - \"\"\n                default: dhcp\n                example: static\n              address:\n                type: string\n                format: ipv4\n                example: 192.168.1.100\n              mask:\n                type: integer\n                minimum: 0\n                maximum: 32\n                default: 24\n                example: 24\n              gateway:\n                type: string\n                format: ipv4\n                example: 192.168.1.1\n              vlan:\n                type: string\n                example: EXP-1\n</code></pre>"},{"location":"schema/#interface-schema","title":"Interface Schema","text":"<pre><code>iface:\n  type: object\n  required:\n  - name\n  - vlan\n  properties:\n    name:\n      type: string\n      example: eth0\n    vlan:\n      type: string\n      example: EXP-1\n    autostart:\n      type: boolean\n      default: true\n    mac:\n      type: string\n      example: 00:11:22:33:44:55\n    mtu:\n      type: integer\n      default: 1500\n      example: 1500\n    bridge:\n      type: string\n      default: phenix\n    driver:\n      type: string\n      example: e1000\niface_address:\n  type: object\n  required:\n  - address\n  - mask\n  properties:\n    address:\n      type: string\n      format: ipv4\n      example: 192.168.1.100\n    mask:\n      type: integer\n      minimum: 0\n      maximum: 32\n      default: 24\n      example: 24\n    gateway:\n      type: string\n      format: ipv4\n      example: 192.168.1.1\n    dns:\n      nullable: true\n      oneOf:\n      - type: string\n      - type: array\n        items:\n          type: string\n      example:\n      - 192.168.1.1\n      - 192.168.1.2\niface_rulesets:\n  type: object\n  properties:\n    ruleset_out:\n      type: string\n      example: OutToInet\n    ruleset_in:\n      type: string\n      example: InFromInet\nstatic_iface:\n  allOf:\n  - $ref: '#/components/schemas/iface'\n  - $ref: '#/components/schemas/iface_address'\n  - $ref: '#/components/schemas/iface_rulesets'\n  required:\n  - type\n  - proto\n  properties:\n    type:\n      type: string\n      enum:\n      - ethernet\n      default: ethernet\n      example: ethernet\n    proto:\n      type: string\n      enum:\n      - static\n      - ospf\n      default: static\n      example: static\ndhcp_iface:\n  allOf:\n  - $ref: '#/components/schemas/iface'\n  - $ref: '#/components/schemas/iface_rulesets'\n  required:\n  - type\n  - proto\n  properties:\n    type:\n      type: string\n      enum:\n      - ethernet\n      default: ethernet\n      example: ethernet\n    proto:\n      type: string\n      enum:\n      - dhcp\n      - manual\n      default: dhcp\n      example: dhcp\nserial_iface:\n  allOf:\n  - $ref: '#/components/schemas/iface'\n  - $ref: '#/components/schemas/iface_address'\n  - $ref: '#/components/schemas/iface_rulesets'\n  required:\n  - type\n  - proto\n  - udp_port\n  - baud_rate\n  - device\n  properties:\n    type:\n      type: string\n      enum:\n      - serial\n      default: serial\n      example: serial\n    proto:\n      type: string\n      enum:\n      - static\n      default: static\n      example: static\n    udp_port:\n      type: integer\n      minimum: 0\n      maximum: 65535\n      default: 8989\n      example: 8989\n    baud_rate:\n      type: integer\n      enum:\n      - 110\n      - 300\n      - 600\n      - 1200\n      - 2400\n      - 4800\n      - 9600\n      - 14400\n      - 19200\n      - 38400\n      - 57600\n      - 115200\n      - 128000\n      - 256000\n      default: 9600\n      example: 9600\n    device:\n      type: string\n      default: /dev/ttyS0\n      example: /dev/ttyS0\n</code></pre>"},{"location":"schema/#complete-schema","title":"Complete Schema","text":"<pre><code>openapi: \"3.0.0\"\ninfo:\n  title: phenix config specs\n  version: \"2.0\"\npaths: {}\ncomponents:\n  schemas:\n    Image:\n      type: object\n      required:\n      - format\n      - mirror\n      - release\n      - size\n      - variant\n      properties:\n        compress:\n          type: boolean\n          default: false\n          example: false\n        deb_append:\n          type: string\n          example: --components=main,restricted\n        format:\n          type: string\n          example: qcow2\n        mirror:\n          type: string\n          example: http://us.archive.ubuntu.com/ubuntu/\n        overlays:\n          type: array\n          nullable: true\n          items:\n            type: string\n          example:\n          - /phenix/vmdb/overlays/example-overlay\n        packages:\n          type: array\n          nullable: true\n          items:\n            type: string\n          example:\n          - isc-dhcp-client\n          - openssh-server\n        ramdisk:\n          type: boolean\n          default: false\n          example: false\n        release:\n          type: string\n          example: focal\n        script_order:\n          type: array\n          nullable: true\n          items:\n            type: string\n          example:\n          - POSTBUILD_APT_CLEANUP\n        scripts:\n          type: object\n          nullable: true\n          additionalProperties:\n            type: string\n          example:\n            POSTBUILD_APT_CLEANUP: |\n              apt clean || apt-get clean || echo \"unable to clean apt cache\"\n        size:\n          type: string\n          example: 10G\n        variant:\n          type: string\n          example: minbase\n    Role:\n      type: object\n      required:\n      - policies\n      - roleName\n      properties:\n        policies:\n          type: array\n          items:\n            type: object\n            properties:\n              resources:\n                type: array\n                items:\n                  type: string\n              resourceNames:\n                type: array\n                items:\n                  type: string\n              verbs:\n                type: array\n                items:\n                  type: string\n          example:\n          - resources:\n            - experiments\n            - experiments/*\n            resourceNames:\n            - '*'\n            verbs:\n            - list\n            - get\n        roleName:\n          type: string\n          example: Example Role\n    User:\n      type: object\n      required:\n      - first_name\n      - last_name\n      - username\n      properties:\n        first_name:\n          type: string\n          example: John\n        last_name:\n          type: string\n          example: Doe\n        password:\n          type: string\n          example: '&lt;encrypted password&gt;'\n          readOnly: true\n        rbac:\n          allOf:\n          - $ref: \"#/components/schemas/Role\"\n          readOnly: true\n        username:\n          type: string\n          example: johndoe@example.com\n    Topology:\n      type: object\n      required:\n      - nodes\n      properties:\n        nodes:\n          type: array\n          items:\n            oneOf:\n            - $ref: '#/components/schemas/minimega_node'\n            - $ref: '#/components/schemas/external_node'\n    Scenario:\n      type: object\n      nullable: true\n      required:\n      - apps\n      properties:\n        apps:\n          type: array\n          nullable: true\n          items:\n            type: object\n            required:\n            - name\n            properties:\n              name:\n                type: string\n                example: example-app\n              assetDir:\n                type: string\n                example: /phenix/topologies/example-topo/assets\n              metadata:\n                type: object\n                nullable: true\n                additionalProperties: true\n                example:\n                  setting0: true\n                  setting1: 42\n                  setting2: universe key\n              hosts:\n                type: array\n                items:\n                  type: object\n                  required:\n                  - hostname\n                  properties:\n                    hostname:\n                      type: string\n                      example: example-host\n                    metadata:\n                      type: object\n                      nullable: true\n                      additionalProperties: true\n                      example:\n                        setting0: true\n                        setting1: 42\n                        setting2: universe key\n    Experiment:\n      type: object\n      required:\n      - topology\n      properties:\n        topology:\n          $ref: \"#/components/schemas/Topology\"\n        scenario:\n          $ref: \"#/components/schemas/Scenario\"\n        baseDir:\n          type: string\n          example: /phenix/topologies/example-topo\n        experimentName:\n          type: string\n          example: example-exp\n          readOnly: true\n        vlans:\n          type: object\n          nullable: true\n          properties:\n            aliases:\n              type: object\n              nullable: true\n              additionalProperties:\n                type: integer\n              example:\n                MGMT: 200\n            min:\n              type: integer\n            max:\n              type: integer\n        schedule:\n          type: object\n          nullable: true\n          additionalProperties:\n            type: string\n          example:\n            ADServer: compute1\n    minimega_node:\n      type: object\n      required:\n      - type\n      - general\n      - hardware\n      properties:\n        type:\n          type: string\n          default: VirtualMachine\n          example: VirtualMachine\n        general:\n          type: object\n          required:\n          - hostname\n          properties:\n            hostname:\n              type: string\n              example: ADServer\n            description:\n              type: string\n              example: Active Directory Server\n            vm_type:\n              type: string\n              enum:\n              - kvm\n              - container\n              - \"\"\n              default: kvm\n              example: kvm\n            snapshot:\n              type: boolean\n              default: false\n              example: false\n              nullable: true\n            do_not_boot:\n              type: boolean\n              default: false\n              example: false\n              nullable: true\n        hardware:\n          type: object\n          required:\n          - os_type\n          - drives\n          properties:\n            cpu:\n              type: string\n              default: Broadwell\n              example: Broadwell\n            vcpus:\n              oneOf:\n              - type: integer\n              - type: string\n              default: 1\n              example: 4\n            memory:\n              oneOf:\n              - type: integer\n              - type: string\n              default: 1024\n              example: 8192\n            os_type:\n              type: string\n              enum:\n              - centos\n              - linux\n              - minirouter\n              - rhel\n              - vyatta\n              - vyos\n              - windows\n              - other\n              default: linux\n              example: windows\n            drives:\n              type: array\n              minItems: 1\n              items:\n                type: object\n                required:\n                - image\n                properties:\n                  image:\n                    type: string\n                    minLength: 1\n                    example: ubuntu.qc2\n                  interface:\n                    type: string\n                    enum:\n                    - ahci\n                    - ide\n                    - scsi\n                    - sd\n                    - mtd\n                    - floppy\n                    - pflash\n                    - virtio\n                    - \"\"\n                    default: ide\n                    example: ide\n                  cache_mode:\n                    type: string\n                    enum:\n                    - none\n                    - writeback\n                    - unsafe\n                    - directsync\n                    - writethrough\n                    - \"\"\n                    default: writeback\n                    example: writeback\n                  inject_partition:\n                    type: integer\n                    default: 1\n                    example: 2\n                    nullable: true\n        network:\n          type: object\n          nullable: true\n          required:\n          - interfaces\n          properties:\n            interfaces:\n              type: array\n              nullable: true\n              items:\n                type: object\n                oneOf:\n                - $ref: '#/components/schemas/static_iface'\n                - $ref: '#/components/schemas/dhcp_iface'\n                - $ref: '#/components/schemas/serial_iface'\n            routes:\n              type: array\n              nullable: true\n              items:\n                type: object\n                required:\n                - destination\n                - next\n                properties:\n                  destination:\n                    type: string\n                    example: 192.168.0.0/24\n                  next:\n                    type: string\n                    example: 192.168.1.254\n                  cost:\n                    type: integer\n                    default: 1\n                    example: 1\n                    nullable: true\n            ospf:\n              type: object\n              nullable: true\n              required:\n              - router_id\n              - areas\n              properties:\n                router_id:\n                  type: string\n                  example: 0.0.0.1\n                areas:\n                  type: array\n                  items:\n                    type: object\n                    required:\n                    - area_id\n                    - area_networks\n                    properties:\n                      area_id:\n                        type: integer\n                        example: 1\n                        default: 1\n                      area_networks:\n                        type: array\n                        items:\n                          type: object\n                          required:\n                          - network\n                          properties:\n                            network:\n                              type: string\n                              example: 10.1.25.0/24\n            rulesets:\n              type: array\n              nullable: true\n              items:\n                type: object\n                required:\n                - name\n                - default\n                - rules\n                properties:\n                  name:\n                    type: string\n                    example: OutToDMZ\n                  description:\n                    type: string\n                    example: From Corp to the DMZ network\n                  default:\n                    type: string\n                    enum:\n                    - accept\n                    - drop\n                    - reject\n                    example: drop\n                  rules:\n                    type: array\n                    items:\n                      type: object\n                      required:\n                      - id\n                      - action\n                      - protocol\n                      properties:\n                        id:\n                          type: integer\n                          example: 10\n                        description:\n                          type: string\n                          example: Allow UDP 10.1.26.80 ==&gt; 10.2.25.0/24:123\n                        action:\n                          type: string\n                          enum:\n                          - accept\n                          - drop\n                          - reject\n                          example: accept\n                        protocol:\n                          type: string\n                          enum:\n                          - tcp\n                          - udp\n                          - tcp_udp\n                          - icmp\n                          - esp\n                          - ah\n                          - all\n                          default: tcp\n                          example: tcp\n                        source:\n                          type: object\n                          nullable: true\n                          required:\n                          - address\n                          properties:\n                            address:\n                              type: string\n                              example: 10.1.24.60\n                            port:\n                              type: integer\n                              example: 3389\n                        destination:\n                          type: object\n                          nullable: true\n                          required:\n                          - address\n                          properties:\n                            address:\n                              type: string\n                              example: 10.1.24.60\n                            port:\n                              type: integer\n                              example: 3389\n        injections:\n          type: array\n          nullable: true\n          items:\n            type: object\n            required:\n            - src\n            - dst\n            properties:\n              src:\n                type: string\n                example: foo.xml\n              dst:\n                type: string\n                example: /etc/phenix/foo.xml\n              description:\n                type: string\n                example: phenix config file\n              permissions:\n                type: string\n                example: '0664'\n        delay:\n          type: object\n          nullable: true\n          properties:\n            timer:\n              type: string\n              example: 5m\n            user:\n              type: boolean\n            c2:\n              type: array\n              nullable: true\n              items:\n                type: object\n                properties:\n                  hostname:\n                    type: string\n                  useUUID:\n                    type: boolean\n        advanced:\n          type: object\n          nullable: true\n          additionalProperties:\n            type: string\n        commands:\n          type: array\n          nullable: true\n          items:\n            type: string\n          example:\n          - exec df -h\n    external_node:\n      type: object\n      required:\n      - external\n      - type\n      - general\n      properties:\n        external:\n          type: boolean\n        type:\n          type: string\n          default: HIL\n          example: HIL\n        general:\n          type: object\n          required:\n          - hostname\n          properties:\n            hostname:\n              type: string\n              example: ADServer\n            description:\n              type: string\n              example: Active Directory Server\n            vm_type:\n              type: string\n              enum:\n              - vm\n              - container\n              - \"\"\n              default: vm\n              example: vm\n        hardware:\n          type: object\n          nullable: true\n          required:\n          - os_type\n          properties:\n            cpu:\n              type: string\n              default: Broadwell\n              example: Broadwell\n            vcpus:\n              oneOf:\n              - type: integer\n              - type: string\n              default: 1\n              example: 4\n            memory:\n              oneOf:\n              - type: integer\n              - type: string\n              default: 1024\n              example: 8192\n            os_type:\n              type: string\n              default: linux\n              example: windows\n        network:\n          type: object\n          nullable: true\n          required:\n          - interfaces\n          properties:\n            interfaces:\n              type: array\n              items:\n                type: object\n                required:\n                - name\n                properties:\n                  name:\n                    type: string\n                    example: eth0\n                  proto:\n                    type: string\n                    enum:\n                    - static\n                    - dhcp\n                    - manual\n                    - \"\"\n                    default: dhcp\n                    example: static\n                  address:\n                    type: string\n                    format: ipv4\n                    example: 192.168.1.100\n                  mask:\n                    type: integer\n                    minimum: 0\n                    maximum: 32\n                    default: 24\n                    example: 24\n                  gateway:\n                    type: string\n                    format: ipv4\n                    example: 192.168.1.1\n                  vlan:\n                    type: string\n                    example: EXP-1\n    iface:\n      type: object\n      required:\n      - name\n      - vlan\n      properties:\n        name:\n          type: string\n          example: eth0\n        vlan:\n          type: string\n          example: EXP-1\n        autostart:\n          type: boolean\n          default: true\n        mac:\n          type: string\n          example: 00:11:22:33:44:55\n        mtu:\n          type: integer\n          default: 1500\n          example: 1500\n        bridge:\n          type: string\n          default: phenix\n        driver:\n          type: string\n          example: e1000\n        qinq:\n          type: boolean\n          default: false\n    iface_address:\n      type: object\n      required:\n      - address\n      - mask\n      properties:\n        address:\n          type: string\n          format: ipv4\n          example: 192.168.1.100\n        mask:\n          type: integer\n          minimum: 0\n          maximum: 32\n          default: 24\n          example: 24\n        gateway:\n          type: string\n          format: ipv4\n          example: 192.168.1.1\n        dns:\n          nullable: true\n          oneOf:\n          - type: string\n          - type: array\n            items:\n              type: string\n          example:\n          - 192.168.1.1\n          - 192.168.1.2\n    iface_rulesets:\n      type: object\n      properties:\n        ruleset_out:\n          type: string\n          example: OutToInet\n        ruleset_in:\n          type: string\n          example: InFromInet\n    static_iface:\n      allOf:\n      - $ref: '#/components/schemas/iface'\n      - $ref: '#/components/schemas/iface_address'\n      - $ref: '#/components/schemas/iface_rulesets'\n      required:\n      - type\n      - proto\n      properties:\n        type:\n          type: string\n          enum:\n          - ethernet\n          default: ethernet\n          example: ethernet\n        proto:\n          type: string\n          enum:\n          - static\n          - ospf\n          default: static\n          example: static\n    dhcp_iface:\n      allOf:\n      - $ref: '#/components/schemas/iface'\n      - $ref: '#/components/schemas/iface_rulesets'\n      required:\n      - type\n      - proto\n      properties:\n        type:\n          type: string\n          enum:\n          - ethernet\n          default: ethernet\n          example: ethernet\n        proto:\n          type: string\n          enum:\n          - dhcp\n          - manual\n          default: dhcp\n          example: dhcp\n    serial_iface:\n      allOf:\n      - $ref: '#/components/schemas/iface'\n      - $ref: '#/components/schemas/iface_address'\n      - $ref: '#/components/schemas/iface_rulesets'\n      required:\n      - type\n      - proto\n      - udp_port\n      - baud_rate\n      - device\n      properties:\n        type:\n          type: string\n          enum:\n          - serial\n          default: serial\n          example: serial\n        proto:\n          type: string\n          enum:\n          - static\n          default: static\n          example: static\n        udp_port:\n          type: integer\n          minimum: 0\n          maximum: 65535\n          default: 8989\n          example: 8989\n        baud_rate:\n          type: integer\n          enum:\n          - 110\n          - 300\n          - 600\n          - 1200\n          - 2400\n          - 4800\n          - 9600\n          - 14400\n          - 19200\n          - 38400\n          - 57600\n          - 115200\n          - 128000\n          - 256000\n          default: 9600\n          example: 9600\n        device:\n          type: string\n          default: /dev/ttyS0\n          example: /dev/ttyS0\n`)\n</code></pre>"},{"location":"scorch/","title":"Scorch","text":"<p>Scorch \u2014 SCenario ORCHestration \u2014 is an automated scenario orchestration framework within phenix. It is included in phenix as a core app. The development of the Scorch framework was motivated by the need to facilitate rigorous experimentation. Some advantages of Scorch include the ability to run many repeated scenarios on an experiment with consistency and minimal overhead. Scorch also provides the ability to efficiently capture experimental data for retrieval and analysis.</p> <p>A phenix scenario configuration file is used to define and configure the Scorch app for use on a topology. The Scorch app is meant to allow for the staging of Scorch components in sequence to execute against a running experiment. When applied to a given topology, the Scorch app will be available in the Scorch table to execute and then observe, manipulate in some cases, and review output from available components for a given stage in the Scorch pipeline.</p> <p>The screenshots and configuration file in the rest of this document are from an example Scorch app, <code>scorch-demo</code>.</p>"},{"location":"scorch/#scorch-components","title":"Scorch Components","text":"<p>A Scorch component is simply an executable available to be called by the Scorch app within phenix. A component is expected to implement any or all of the various stages in the Scorch pipeline.</p> <p>For an executable to be considered a Scorch component, it must meet the following requirements:</p> <ol> <li>Follow the <code>phenix-scorch-component-&lt;type&gt;</code> naming convention, where <code>&lt;type&gt;</code> is the component type used in the Scorch app configuration. An example would be <code>phenix-scorch-component-tcpdump</code>.</li> <li>Be an executable file.</li> <li>Be in the <code>PATH</code> of the user running phenix.</li> </ol> <p>When the Scorch app executes a Scorch component, it will pass a number of positional arguments to the component via the command line, as well as the JSON representation of the experiment the component is to be executed against via STDIN. The positional arguments passed are as follows:</p> <ol> <li>run stage (<code>configure</code>, <code>start</code>, <code>stop</code>, or <code>cleanup</code>)</li> <li>component name (name given to component type in Scorch app configuration)</li> <li>run ID (integer <code>&gt;= 0</code> representing the array index of the Scorch run in the app configuration being executed)</li> <li>loop (integer <code>&gt;= 0</code> representing the current run loop being executed)</li> <li>count (integer <code>&gt;= 0</code> representing the current loop count being executed)</li> </ol> <p>During component execution, the Scorch app assumes anything written to STDOUT by a component is intended to be relayed to the user. Thus, when Scorch is run via the web UI, anything written to STDOUT gets streamed to the UI for viewing. Any error messages generated by a component should be written to the log file or to STDERR unless it's to also be relayed to the user directly.</p> <p>The Scorch app expects a component executable to exit with a value of <code>0</code> upon completion if the component was successful, and exit with any other value otherwise. An exit value of anything other than <code>0</code> will result in Scorch halting execution of the current stage and jumping to the next appropriate stage to complete the Scorch run.</p>"},{"location":"scorch/#automated-component-data-collection","title":"Automated Component Data Collection","text":"<p>The Scorch app is capable of generating a configuration file for and starting an instance of Filebeat in the background before execution of each Scorch run. As each Scorch component is executed, any data it generates and collects can be configured to be automatically processed by Filebeat for indexing in Elasticsearch. At a minimum, this requires the following.</p> <ol> <li>Filebeat to be enabled and configured in the Scorch app configuration.</li> <li>A Filebeat input to be configured for each component generating and collecting data.</li> <li>The <code>filebeat</code> executable installed and in the <code>PATH</code> of the user running phenix.</li> </ol> <p>See the example configuration below for examples of how Filebeat and Filebeat inputs are configured in the Scorch app configuration.</p>"},{"location":"scorch/#built-in-components","title":"Built-in Components","text":"<p>The following Scorch component types are considered <code>core</code> components, in that they are included in the main phenix repository and are available for use in Scorch app configurations by default.</p> <ul> <li>break</li> <li>pause</li> <li>soh</li> <li>tap</li> </ul>"},{"location":"scorch/#break-component","title":"<code>break</code> Component","text":"<p>The <code>break</code> component is comparable to a source code break point when debugging an application in that it pauses execution of the current Scorch run until a user exits the break. While the <code>break</code> component is running, users have access to a shell on the server running phenix as the user running phenix. The first user to access the shell via the terminal modal in the UI will have read-write access. If other users access the shell, they will have read-only access but will get live updates as the user with read-write access uses the terminal.</p> <p>It's possible to configure the <code>break</code> component in the Scorch app configuration to create a minimega tap when the component is executed. When the component is executed, the tap will be deleted. In addition to the tap, external network access can also be configured (e.g., Internet access).</p> <p>An example of configuring a <code>break</code> component to create a tap and configure external network access during the <code>configure</code> stage is as follows. The <code>break</code> component can be configured to run in any stage.</p> <pre><code>spec:\n  apps:\n  - name: scorch\n    metadata:\n      components:\n      - name: break-tap\n        type: break\n        metadata:\n          tap:\n            bridge: phenix\n            vlan: MGMT\n            ip: 172.16.33.25/16\n            internetAccess: true\n      runs:\n      - configure: [\"break-tap\"]\n</code></pre>"},{"location":"scorch/#pause-component","title":"<code>pause</code> Component","text":"<p>The <code>pause</code> component is similar to the <code>break</code> component in that it pauses execution of the current Scorch run, but instead of waiting for user intervention it simply pauses for a predefined duration.</p> <p>A simple example is as follows. The <code>pause</code> component can be configured to run in any stage. The value used for the <code>duration</code> key should be a valid Golang duration string.</p> <pre><code>spec:\n  apps:\n  - name: scorch\n    metadata:\n      components:\n      - name: brief-pause\n        type: pause\n        metadata:\n          duration: 2s\n      runs:\n      - start: [\"brief-pause\"]\n</code></pre>"},{"location":"scorch/#soh-component","title":"<code>soh</code> Component","text":"<p>The <code>soh</code> component allows users to execute the State of Health app at scheduled times throughout a Scorch run. This is handy when, for example, other Scorch components might cause nodes in the experiment to misbehave or fail. The component can be configured to limit which health checks are run, and can also be configured to fail if any of the health checks fail. The log level can also be configured, which will limit what logs get sent to the component's UI modal while the component is running.</p> <pre><code>spec:\n  apps:\n  - name: scorch\n    metadata:\n      components:\n      - name: health-check\n        type: soh\n        metadata:\n          c2Timeout: 5s # if provided, will update the C2 timeout setting when this component runs the state of health app\n          checks:       # default is to run all the following checks\n            - network-config       # Ensure all nodes still have network configured per the topology. Will use `skipInitialNetworkConfigTests` setting in soh app config.\n            - reachability         # Basic ICMP-based reachability testing. Will use `testReachability` setting in soh app config.\n            - custom-reachability  # IP-based reachability testing (TCP or UDP). Will use `testCustomReachability` setting in soh app config.\n            - processes            # Ensure processes are running in nodes. Will use `hostProcesses` setting in soh app config.\n            - ports                # Ensure listeners are running in nodes. Will use `hostListeners` setting in soh app config.\n            - custom               # Run custom tests in nodes. Will use `hostCustomTests` setting in soh app config.\n            - cpu-load             # Gather CPU load stats from nodes.\n            - flows                # Gather paket flows from ElasticSearch server. Requires `packetCapture` setting to be cofigured in soh app config.\n          failOnError: true # default is false\n          logLevel: debug   # default is info\n      runs:\n      - start: [\"health-check\"]\n</code></pre>"},{"location":"scorch/#tap-component","title":"<code>tap</code> Component","text":"<p>The <code>tap</code> component implements the exact same functionality described above in the <code>break</code> component for creating a minimega tap and, optionally, external network access, but allows for the tap (and external network access, if configured) to exist while other components are executed (as opposed to only existing for the duration of the <code>break</code> component).</p> <p>An example of configuring a <code>tap</code> component to create a tap and configure external network access is as follows. The <code>tap</code> component can only be configured to run in the <code>start</code> stage (create the tap) and the <code>stop</code> stage (delete the tap).</p> <pre><code>spec:\n  apps:\n  - name: scorch\n    metadata:\n      components:\n      - name: tap-inet\n        type: tap\n        metadata:\n          bridge: phenix\n          vlan: MGMT\n          ip: 172.16.33.25/16\n          internetAccess: true\n      runs:\n      - start: [\"tap-inet\"]\n      - stop: [\"tap-inet\"]\n</code></pre> <p>NOTE: In deployments where <code>minimega</code> is running in a container on the headnode, and Docker networking is in use (e.g., the <code>minimega</code> container is not configured to use host networking), users will need to execute the following commands if access to the <code>minimega</code> tap created by the <code>tap</code> (or <code>break</code>) component from the Docker host is required.</p> <pre><code>ovs-docker add-port phenix TDN minimega\ndocker exec -it minimega ovs-vsctl add-port phenix TDN\novs-vsctl add-port phenix temp-tap tag=&lt;vlan ID&gt; -- set interface temp-tap type=internal\n</code></pre> <p>The above commands assume the name of the minimega container is <code>minimega</code>. The name of the local tap created (in this case, <code>temp-tap</code>) can be whatever, but the value for the VLAN tag must match the numerical ID of the VLAN that's mapped to the VLAN alias used in the <code>tap</code> (or <code>break</code>) component configuration.</p> <p>Using host networking mode for the <code>minimega</code> container allows for all the above nonsense to be skipped.</p>"},{"location":"scorch/#user-defined-components","title":"User-defined Components","text":"<p>The following Scorch component types have been developed external to the main phenix repository and are available in the sceptre-phenix-apps repository, which also includes README-based documentation for each component. They are all developed in Python, and leverage common helper classes that ease the development of user components.</p> App Link Description art link Atomic Red Team caldera link Executes operations in MITRE Caldera via the REST API. cc link minimega Command and Control (cc) Component. collector link Collects and processes data from cyber-physical experiments and Scorch components. disruption link Orchestrates and executes disruption scenarios for cyber-physical experiments. ettercap link Component that runs Ettercap, relies on <code>ettercap</code> executable in the VM. hoststats link Collects statistics on minimega host(s). iperf link Collects network performance measurements using iperf3 or rperf. mm link minimega (mm) Component. opcexport link Exports data from an OPC server to Elasticsearch. pcap link Collects PCAPs from VMs via minimega's <code>capture pcap</code> API. qos link Apply Quality of Service (QoS) effects on network interfaces, including dropping packets (loss), delaying packets (delay), or limiting bandwidth (rate). rtds link Collects and verifies data from the Real-Time Dynamic Simulator (RTDS), and orchestrates the starting/stopping of RSCAD cases. snort link Configures and runs Snort. Snort must be installed on VMs. tcpdump link Executes and collects and processes data from <code>tcpdump</code>. trafficgen link Traffic Generator. vmstats link Collects resource utilization statistics from Linux VMs in the experiment, using the <code>vmstats</code> command."},{"location":"scorch/#scorch-table","title":"Scorch Table","text":"<p>The Scorch table, accessible as one of the tab selections within the phenix UI, lists all possible Scorch apps available based on the experiments established in phenix. The following columns or functions are available:</p> <ul> <li>Experiment name</li> <li>Experiment status: this reports on the status of the experiment \u2014 an experiment must be running for a Scorch app to start</li> <li>Scorch app status: this will report the running or stopped status of the Scorch app itself</li> <li>Terminal: if the Scorch app has reached a break point, a terminal will be available \u2014 if clicked, a terminal dialog will be opened and is running on the phenix host system</li> <li>Find an Experiment: similar to the search fields in other tables within the phenix UI, it is possible to filter experiment names based on terms entered here</li> </ul> <p></p>"},{"location":"scorch/#scorch-pipeline","title":"Scorch Pipeline","text":"<p>Scorch pipelines are available on the Scorch table in the phenix UI. The table is sorted by Experiment name by default. Only those experiments with the Scorch app configured in the scenario configuration will be listed in the table. It is possible to start or stop an experiment, as well as start or stop a Scorch component. Finally, if a terminal is available when a break point is reached in a running Scorch app, it can be accessed from the table.</p> <p>The Scorch pipeline provides a graphical representation of the Scorch app, including the <code>configure, start, stop, and cleanup</code> stages. If the Scorch app provides output for a given step, or component, users can click into the component and receive the output. A user can access the terminal if a break point is reached by clicking on the component. As with the terminal access described above, a dialog will be presented with a terminal running on the phenix host system.</p> <p></p> <p>The following functions are also available in the Scorch pipeline UI:</p> <ul> <li>Return to the table: a button that will return to the Scorch table</li> <li>Scorch app status: a button that will allow a running Scorch app to be stopped or started depending on the current status</li> </ul> <p></p> <p></p>"},{"location":"scorch/#stages","title":"Stages","text":"<p>For a given Scorch pipeline, there are four stages of execution:</p> <ol> <li><code>configure</code></li> <li><code>start</code></li> <li><code>stop</code></li> <li><code>cleanup</code></li> </ol> <p>A Scorch component may implement any or all of the various stages, and Scorch will execute each stage inside the components in order. Each component can be configured in the Scorch app scenario configuration file.</p> <p>* There is additional <code>done</code> stage in the UI obtained when <code>cleanup</code> has been completed. It is meant to report the completion of all stages in the Pipeline UI.</p> <p>It's completely up to the component developer if and how an execution stage is implemented and handled by the component. If a component is configured in the Scorch app to be executed as part of a stage, but the component does not implement said stage, then the Scorch app will happily continue on to the next component in the stage (unless the component errors out if the current stage is not implemented, in which case the Scorch run will fail).</p> <p></p> <p>The following indicators are presented for each component of the Scorch app:</p> <ul> <li>Uninitialized: a component has not yet been reached or initialized \u2014 if the component has not yet been run, all components will be identified as uninitialized</li> <li>Running: the component is currently running and has not yet been completed</li> <li>Success: the component has completed successfully</li> <li>Break Point: a break component has been reached \u2014 a terminal should be accessible by clicking on the component</li> <li>Backgrounded: a component is running in the background</li> <li>Failure: a component has failed for some reason \u2014 reporting on the failure may be accessible by click on the component</li> </ul> <p></p> <p>Loops are also available within a Scorch app and are included in the configuration file. A loop supports looping within a given component through additional components. Once a loop is completed, the next component is executed. There is no limit on the number of loops or depth of them. The Scorch pipeline UI supports access to each loop and will report the depth in the pipeline's title. The first loop in the <code>scorch-demo</code> app is presented in the following example; clicking the return button will return the display one level up in the loop chain (or ending at the parent Scorch app).</p> <p></p> <p>In addition to loops, multi-run is supported within a Scorch app. Unlike loops, multi-run allows for individual Scorch runs containing four separate stages. They are not nested in each other but are independent runs. A use case for multi-run could be executing multiple independent portions of an experiment against a topology, in any order or executing a run multiple times. There are two runs depicted in the configuration below.</p> <p>As described above, each component will provide a modal for output reporting. The output could either be a fairly straight forward report, nothing at all, or it  include logging output for a given component in the stage. The result will be streamed as it is received if the component is currently in a running component. If the component has finished running, the output will be static.</p> <p></p> <p>A terminal modal is available from the Scorch table when a break point component is reached; it is also available in the Scorch pipeline. There are two types of terminal modals: read-write and read-only. If another user opens a terminal modal for a given component, it will be read-only the next time a terminal is open. The following are examples of each. In the first example, a read-only terminal, the user viewing this modal is only observing what another using is executing. In the second example, a read-write terminal, the user ran two simple commands on the phenix host system.</p> <p></p> <p></p> <p>If a component fails, the Scorch app will skip the remaining components involved in the current execution stage and jump to the next appropriate stage to complete the Scorch run. For example, if a component fails in the <code>Configure</code> stage the Scorch app will jump to the <code>Cleanup</code> stage, and if a component fails in the <code>Start</code> stage Scorch will jump to the <code>Stop</code> stage (skipping execution of any configured loops in either case).</p> <p></p>"},{"location":"scorch/#example-configuration","title":"Example Configuration","text":"<pre><code>apiVersion: phenix.sandia.gov/v2\nkind: Scenario\nmetadata:\n  name: scorch-demo\nspec:\n  scenario:\n    apps:\n    - name: mirror\n      metadata:\n        directGRE:\n          enabled: true\n          mirrorBridge: phenix\n          mirrorNet: 172.30.0.0/16\n          mirrorVLAN: mirror\n      hosts:\n      - hostname: detector\n        metadata:\n          interface: IF0\n          vlans:\n          - EXP\n      - name: scorch\n        metadata:\n          components:\n          - name: vmstats\n            type: vmstats\n            metadata:\n              filebeat.inputs:\n              - enabled: true\n                type: log\n                json.add_error_key: true\n                paths:\n                - vm_stats.jsonl\n                processors:\n                - copy_fields:\n                    fields:\n                    - from: json\n                      to: scorch.vmstats\n                - drop_fields:\n                    fields:\n                    - json\n                - timestamp:\n                    field: scorch.vmstats.UTC\n                    layouts:\n                    - '2006-01-02 15:04:05'\n          - name: hoststats\n            type: hoststats\n            background: true\n            metadata:\n              filebeat.inputs:\n              - enabled: true\n                type: log\n                json.add_error_key: true\n                paths:\n                - host_stats.jsonl\n                processors:\n                - copy_fields:\n                    fields:\n                    - from: json\n                      to: scorch.hoststats\n                - drop_fields:\n                    fields:\n                    - json\n                - timestamp:\n                    field: scorch.hoststats.timestamp\n                    layouts:\n                    - UNIX_MS\n          - name: trafficgen\n            type: trafficgen\n            metadata:\n              scripts:\n                backgroundGen: /phenix/topologies/scorch-demo/scripts/background-gen.py\n                malwareGen: /phenix/topologies/scorch-demo/scripts/malware-gen.py\n                trafficServer: /phenix/topologies/scorch-demo/scripts/traffic-server.py\n              targets:\n              - backgroundClient:\n                  hostname: background-gen\n                  probability: 0.01\n                  rate: 10000\n                duration: 30\n                hostname: traffic-server\n                interface: IF0\n                malwareClient:\n                  hostname: malware-gen\n                  probability: 1.25\n                  rate: 20\n          - name: break\n            type: break\n            metadata: {}\n          - name: tcpdump\n            type: tcpdump\n            metadata:\n              convertToJSON: false\n              filebeat.inputs:\n              - enabled: true\n                type: log\n                paths:\n                - tcpdump.pcap.json\n                processors:\n                - copy_fields:\n                    fields:\n                    - from: json\n                      to: scorch.tcpdump\n                - drop_fields:\n                    fields:\n                    - json\n              vms:\n                detector: eth0\n          - name: snort\n            type: snort\n            metadata:\n              configs:\n              - dst: /etc/snort/snort.conf\n                name: snort\n                src: /phenix/topologies/scorch-demo/configs/snort.conf\n              - dst: /etc/snort/rules/emotet.rules\n                name: emotet\n                src: /phenix/topologies/scorch-demo/configs/emotet.rules\n              filebeat.inputs:\n              - enabled: true\n                type: log\n                json.add_error_key: true\n                paths:\n                - snort-stats.jsonl\n                processors:\n                - copy_fields:\n                    fields:\n                    - from: json\n                      to: scorch.snort\n                - drop_fields:\n                    fields:\n                    - json\n                - timestamp:\n                    field: scorch.snort.timestamp\n                    layouts:\n                    - UNIX\n              hostname: detector\n              scripts:\n                configSnort:\n                  executor: bash\n                  script: /phenix/topologies/scorch-demo/scripts/configure-snort.sh\n              sniffInterface: eth0\n              waitDuration: 5\n          runs:\n          - configure:\n            - trafficgen\n            - snort\n            start:\n            - hoststats\n            - vmstats\n            loop:\n              execute:\n                configure: null\n                start:\n                - tcpdump\n                - snort\n                - trafficgen\n                stop:\n                - trafficgen\n                - snort\n                - tcpdump\n                cleanup: null\n            stop:\n            - vmstats\n            - hoststats\n            - break\n          - start:\n            - tcpdump\n            - trafficgen\n            stop:\n            - trafficgen\n            - tcpdump\n          filebeat:\n            enabled: true\n            config:\n              output.elasticsearch:\n                hosts:\n                - es:9200\n              setup.dashboards.enabled: true\n              setup.kibana.host: http://kibana:5601\n</code></pre>"},{"location":"state-of-health/","title":"State of Health","text":"<p>State of Health (SoH) is a core (but not default) app meant to assist with understanding the state of a running experiment. It has many configuration options, and relies on minimega's command and control infrastructure (ie. the <code>miniccc</code> agent running in experiment VMs) to drive and collect the experiment health state data. See the command and control section for more details.</p> <p>SoH information is presented in the UI in three separate tabs. You can access the information by clicking the SoH button from the Experiments or Running Experiment components.</p> <p>Button available on the experiments table.</p> <p></p> <p>Button available in running experiment.</p> <p></p>"},{"location":"state-of-health/#topology-graph","title":"Topology Graph","text":"<p>This tab displays a network graph of the running experiment.</p> <p></p> <p>The color of the node is based on the condition of the corresponding VM and could be:</p> <ul> <li><code>Running</code></li> <li><code>Not running</code> (part of the experiment, but currently paused)</li> <li><code>Not booted</code> (part of the experiment, but marked as Do Not Boot)</li> <li><code>Not deployed</code> (part of the experiment, but flushed from minimega)</li> <li><code>Experiment stopped</code></li> </ul> <p></p> <p>It is also possible to filter the graph based on nodes that are either:</p> <ul> <li><code>Running</code>,</li> <li><code>Not running</code>,</li> <li><code>Not booted</code>, or</li> <li><code>Not deployed</code>.</li> </ul> <p>The <code>Refresh Network</code> button will reset the filter, showing all nodes. </p> <p>The <code>Manual Refresh</code> button will request the latest server-side SoH data and update the three tabs.</p> <p>Hovering over a node in the graph will cause it to expand to show what operating system the node is running. An orange border around a node is indicative of the node currently having health issues (e.g., expected processes not running or not being able to reach other nodes on the network). Other virtual systems will also be represented accordingly (e.g., a printer or firewall).</p> <p></p> <p>Clicking on the node with an orange border will produce a details modal with the current error reporting.</p> <p></p> <p>If there are no errors to report and command and control is enabled, the details modal will only show the current CPU load.</p> <p></p> <p>Note the green button in the lower right corner of the modal; this will provide access to the VNC for any running VM. When the VM is not running, access to the VNC will be disabled. Finally, if there is no SoH information to report on a  given VM, it will be noted in the details modal. The following screenshot is an example of no SoH information with the VNC button disabled.</p> <p></p>"},{"location":"state-of-health/#network-volume","title":"Network Volume","text":"<p>This tab displays a chord graph that shows network flows between nodes using flows from Packetbeat fed to Elasticsearch; connections represent the volume of traffic between nodes.</p> <p>Tip</p> <p>This information is only available if the packet capture option is enabled for SoH.</p> <p>This is an example chord graph of a Protonuke server with two clients; one of which is requesting content at a delayed interval (therefore less traffic flow).</p> <p></p> <p>If you hover over traffic flow, a tooltip will appear providing additional details. (In this screenshot, the mouse is hovering over the traffic for IP <code>192.168.100.1</code>.)</p> <p></p>"},{"location":"state-of-health/#soh-messages","title":"SoH Messages","text":"<p>The final tab will display any error messages from the SoH agents.</p> <p></p>"},{"location":"state-of-health/#configuration","title":"Configuration","text":"<p>Just like any other app, the SoH app is configured via the <code>Scenario</code> configuration. SoH will only be enabled for an experiment if it's present in the scenario as <code>soh</code>, and has multiple configuration options available, described in detail below.</p>"},{"location":"state-of-health/#sample-soh-scenario-config","title":"Sample SoH Scenario Config","text":"<pre><code>spec:\n  apps:\n  - name: soh\n    metadata:\n      appMetadataProfileKey: sohProfile # metadata key to look for in other apps\n      c2Timeout: 5m\n      exitOnError: false\n      startupDelay: 5m                  # only delays at experiment start (PostStart phase)\n      hostCustomTests:\n        host-00:\n        - name: FooBarTest\n          testScript: |\n            cat /etc/passwd | grep root\n          validateStdout: |\n            count=$(wc -l)\n            [[ $count -eq 1 ]] &amp;&amp; exit 0 || exit 1\n          executor: bash\n        host-01:\n        - name: SuckaTest.ps1\n          testScript: |\n            Get-Process miniccc -ErrorAction SilentlyContinue\n          testStdout: miniccc\n          executor: powershell -NoProfile -ExecutionPolicy bypass -File\n      hostListeners:\n        client:\n        - :502\n        server:\n        - :80\n        - :443\n      hostProcesses:\n        client:\n        - miniccc\n        server:\n        - miniccc\n      hostsToUseUUIDForC2Active:\n      - host-02\n      injectICMPAllow: true\n      packetCapture:\n        elasticImage: /phenix/images/elasticsearch.qc2\n        packetBeatImage: /phenix/images/packetbeat.qc2\n        elasticServer:\n          hostname: soh-elasticsearch-server\n          vcpus: 4\n          memory: 4096\n          ipAddress: 172.16.200.1/16\n          vlan: MGMT\n        captureHosts:\n          client:\n          - IF0 # interface to monitor on \"client\" node in topology\n          server:\n          - IF0 # interface to monitor on \"server\" node in topology\n      skipInitialNetworkConfigTests: false # if true, testReachability will be off\n      skipHosts:\n      - kali.qc2 # can be an image name, in which case any host using image will be skipped\n      - foobar-host # can be hostname from topology\n      testReachability: full # can be off, sample, or full\n      testCustomReachability:\n      - src: host-00\n        dst: host-01|IF0\n        proto: tcp\n        port: 22\n        wait: 30s\n      - src: host-01\n        dst: host-00|IF0\n        proto: tcp\n        port: 22\n        wait: 30s\n</code></pre>"},{"location":"state-of-health/#configuration-options","title":"Configuration Options","text":"<ul> <li> <p><code>appMetadataProfileKey</code>: since the listeners and processes one might want to   monitor could be highly dependent on other apps that are configured for an   experiment, it's possible to specify the <code>hostListeners</code> and <code>hostProcesses</code>   to be monitored in the other apps themselves under the key specified here.   The default key is <code>sohProfile</code>.</p> </li> <li> <p><code>c2Timeout</code>: a Golang duration   string specifying how long to   wait for the <code>miniccc</code> C2 client to become active in a VM before moving on and   marking the VM as not to be monitored. The default is <code>5m</code>.</p> </li> <li> <p><code>exitOnError</code>: a boolean representing whether the app should cause the entire   experiment deployment to fail if it has any errors. The default is <code>false</code>.</p> </li> <li> <p><code>startupDelay</code>: a Golang duration   string specifying how long to   wait before initiating checks at the experiment starts. This can be useful   when some processes are not healthy immediately at experiment start. This   only delays SoH when it first runs at the experiment start. It will not delay   SoH when run manually later by clicking the 'Run SoH' button in the UI or   using the command line <code>trigger-running</code> command. The default is no delay.</p> </li> <li> <p><code>hostCustomTests</code>: If present, a map of custom tests to run on the given   hosts.</p> <ul> <li> <p><code>name</code>: name of test. Used as script name to be sent to the host.</p> </li> <li> <p><code>testScript</code>: the actual script (can be multiple lines) to be executed   using the specified <code>executor</code>.</p> </li> <li> <p><code>executor</code>: the application to execute the <code>testScript</code> with (e.g. <code>bash</code>,   <code>powershell</code>).</p> </li> <li> <p><code>testStdout</code>: a string to look for in STDOUT from the executed script. If   found, the test passes. If not found, it fails.</p> </li> <li> <p><code>testStderr</code>: a string to look for in STDERR from the executed script. If   found, the test passes. If not found, it fails.</p> </li> <li> <p><code>validateStdout</code>: a script to run that will be provided, via STDIN, the   STDOUT from the executed script. If this validation script exits 0, the   test passes. If it exits non-zero, the test fails. This validation script   should always be a bash script, even if the host is a Windows host.</p> </li> <li> <p><code>validateStderr</code>: a script to run that will be provided, via STDIN, the   STDERR from the executed script. If this validation script exits 0, the   test passes. If it exits non-zero, the test fails. This validation script   should always be a bash script, even if the host is a Windows host.</p> </li> </ul> </li> <li> <p><code>hostListeners</code>: a map of VMs, each specifying a list of listening ports to   check for within the VM. If the port can be listening on any interface, the   form <code>:80</code> can be used. If the port should be listening on a specific   interface, the form <code>192.168.1.10:80</code> can be used. The default is <code>nil</code>.</p> </li> <li> <p><code>hostProcesses</code>: a map of VMs, each specifying a list of process names to   check for within the VM. The default is <code>nil</code>.</p> </li> <li> <p><code>hostsToUseUUIDForC2Active</code>: a list of topology hostnames to use the minimega   VM UUID for when determining if their cc agent is active. This is useful for   topology nodes that are configured with snapshots disabled, preventing their   hostname from getting updated when booted. Note that this configuration option   also supports being set to <code>all</code> (e.g., <code>hostsToUseUUIDForC2Active: all</code>) if a   user wishes to use the minimega VM UUID for all topology nodes.</p> </li> <li> <p><code>injectICMPAllow</code>: a boolean representing whether any existing firewall/router   rulesets should have a rule added to allow ICMP between all nodes to   facilitate reachability testing. See Injecting ICMP   Rules for more details. If reachability tests are   disabled, then this will be too, regardless of its setting here. The default   is <code>false</code>.</p> </li> <li> <p><code>packetCapture</code>: if present, a partially hidden packet capture infrastructure   based on Elasticsearch, Kibana, and Packetbeat will be deployed for the experiment.   See Packet Capture for more details. The default is <code>nil</code>.</p> <ul> <li> <p><code>elasticImage</code>: path to the disk image to use for the Elastic/Kibana VM   for packet capture. An <code>image/PHENIX-elasticsearch</code> config comes bundled with   phenix and can be used to build an image to use here. There is no default   for this setting; if packet capture is to be deployed it must be provided.</p> </li> <li> <p><code>packetBeatImage</code>: path to the disk image to use for the Packetbeat VM for   packet capture. An <code>image/PHENIX-packetbeat</code> config comes bundled with phenix and   can be used to build an image to use here. There is no default for this   setting; if packet capture is to be deployed it must be provided.</p> </li> <li> <p><code>elasticServer</code>: </p> <ul> <li> <p><code>hostname</code>: the hostname to use for the Elastic/Kibana server added to   the experiment topology. There is no default for this setting; if   packet capture is to be deployed it must be provided.</p> </li> <li> <p><code>vcpus</code>: the number of CPUs to assign to the Elastic/Kibana server VM.   The default is 4.</p> </li> <li> <p><code>memory</code>: the amount of memory to assign to the Elastic/Kibana server   VM. The default is 4096.</p> </li> <li> <p><code>ipAddress</code>: the IP address to use for the Elastic/Kibana server added   to the experiment topology. The network interface this IP address is   used for will be added to the experiment VLAN specified by <code>vlan</code>. The   IP address should be specified in CIDR notation. There should also be   sufficient IP addresses after the one specified here to be assigned to   each of the Packetbeat monitor VMs that will be deployed, as the IP   addresses assigned to them on the VLAN specified by <code>vlan</code> will   increment up from this IP. There is no default for this setting; if   packet capture is to be deployed it must be provided.</p> </li> <li> <p><code>vlan</code>: the experiment VLAN to add the Elastic/Kibana and Packetbeat   VMs to. There is no default for this setting; if packet capture is to   be deployed it must be provided.</p> </li> </ul> </li> <li> <p><code>captureHosts</code>: a map of VMs, each specifying a list of network interface   names to monitor. One Packetbeat VM will be deployed for each VM interface   specified. The defalt is <code>nil</code>.</p> </li> </ul> </li> <li> <p><code>skipInitialNetworkConfigTests</code>: by default, a set of tests will be run on   each VM to ensure the VM was assigned the correct IP address and can reach its   default gateway (if specified). Setting this to true will skip these initial   tests, but will also disable reachability testing. The default is <code>false</code>.</p> </li> <li> <p><code>skipHosts</code>: a list of VM hostnames and/or disk image names to skip health   monitoring for. For disk image names, any host using the disk image as its   primary image will be skipped. The default is <code>nil</code>.</p> </li> <li> <p><code>testReachability</code>: reachability testing is the process of making sure each VM   can reach other VMs within the experiment over the network. See Network   Reachability for more details. There are three options   for this setting: <code>off</code>, <code>sample</code>, <code>full</code>.</p> <ul> <li> <p><code>off</code>: reachability testing is disabled. This is the default.</p> </li> <li> <p><code>sample</code>: each VM in the experiment will attempt to ping a random VM in   every other experiment VLAN.</p> </li> <li> <p><code>full</code>: each VM in the experiment will attempt to ping every other VM in   every other experiment VLAN.</p> </li> </ul> </li> <li> <p><code>testCustomReachability</code>: if present, a list of custom reachability test   settings.</p> <ul> <li> <p><code>src</code>: hostname to conduct test from.</p> </li> <li> <p><code>dst</code>: hostname and interface name (e.g. <code>host-01|IF0</code>) to conduct test   to.</p> </li> <li> <p><code>proto</code>: protocol to use for test. Currently the options are <code>tcp</code> and   <code>udp</code>. If <code>udp</code> is used, the <code>udpPacketBase64</code> setting must be provided.</p> </li> <li> <p><code>port</code>: destination port to conduct test to.</p> </li> <li> <p><code>wait</code>: amount of time to wait for a response from the destination. If not   provided, the default of <code>5s</code> is used.</p> </li> <li> <p><code>udpPacketBase64</code>: a base64-encoded packet to send when testing using   <code>udp</code>. This is required to generate a response over UDP to determine if   the remote server is up and reachable. The given packet must be valid   enough to generate a response from the server.</p> </li> </ul> </li> </ul>"},{"location":"state-of-health/#network-reachability","title":"Network Reachability","text":"<p>Testing network reachability for a VM requires that the VM has minimega's command and control (C2) layer active (ie., the <code>miniccc</code> agent is running in the VM), has the correct IP address configured, and can ping its default route if one is configured. If C2 is not active for a VM after the <code>c2Timeout</code> duration has passed, then the VM will be excluded from reachability testing. Once C2 is up for a VM, the VM is queried to confirm its IP address is configured and its gateway is reachable for a maximum of 5 minutes. Once all the VMs with C2 detected have their IP address configured and their gateways are reachable, reachability tests begin.</p> <p>Reachability tests are run in the post-start stage and each time the running stage is triggered. Given this, if for some reason a VM comes up with its C2 agent active, but its network has to be configured manually, it will not be included in reachability tests during the post-start stage. Once the VM's network settings have been configured manually, the running stage can be triggered and the VM will be included in reachability tests this time around.</p>"},{"location":"state-of-health/#injecting-icmp-rules","title":"Injecting ICMP Rules","text":"<p>The <code>injectICMPAllow</code> option can be used to add rules to routers/firewalls in the topology to prevent reachability tests from failing due to ACLs. When enabled, all rulesets present in the experiment (either in the topology or scenario) will have a rule prepended to the list of existing rules allowing the ICMP protocol to/from any address. To ensure this rule is applied before any other rule, the SoH app attempts to inject it with an ID of 1 (since Vyatta/VyOS orders rules by ID). If a rule already exists with an ID of 1 then injecting this rule will fail.</p> <p>A check is done each time an experiment is started to see if injecting ICMP rules is enabled, and if not, any injected rules are removed from the experiment. This means the setting can be changed between runs of an experiment (e.g., using <code>phenix config edit experiment/&lt;name&gt;</code>) and the change will be reflected accurately when the experiment is started again.</p>"},{"location":"state-of-health/#packet-capture","title":"Packet Capture","text":"<p>The SoH packet capture capability leverages minimega's tap mirroring to monitor traffic on experiment VM interfaces with Packetbeat and feed network flow data to Elasticsearch.</p> <p>When enabled, an Elasticsearch/Kibana VM is added to the experiment's topology so it can be accessed via the phenix UI. Packetbeat VMs are deployed in minimega for each experiment VM interface that's configured to be monitored, but are not added to the experiment topology so they do not clutter the phenix UI.</p> <p>When packet capture is enabled, the phenix UI SoH tab will include a Network Volume tab that uses network flow data queried from Elasticsearch to populate a chord graph in an effort to depict how much traffic is flowing between VMs. Users/Analysts can also access Kibana using VNC via the phenix UI to do additional analysis on the network flow data that's being captured.</p>"},{"location":"state-of-health/#command-and-control","title":"Command and Control","text":"<p>As mentioned above, SoH relies on minimega's command and control infrastructure to drive and collect the experiment health state data. Under the hood, the SoH app uses C2 to execute a test on a VM (<code>cc exec</code>), wait for the command to complete (<code>cc commands</code>), grab the STDOUT/STDERR of the command (<code>cc responses</code>), and compare it to an expected response. </p> <p>Current tests executed on Linux VMs include the following:</p> <ul> <li><code>ip addr</code></li> <li><code>ip route</code></li> <li><code>ping -c 1 &lt;ip&gt;</code></li> <li><code>pgrep -f &lt;process&gt;</code></li> <li><code>ss -lntu state all 'sport = &lt;port&gt;'</code></li> <li><code>cat /proc/loadavg</code></li> </ul> <p>Corresponding tests for Windows VMs include the following:</p> <ul> <li><code>ipconfig /all</code></li> <li><code>route print</code></li> <li><code>ping -n 1 &lt;ip&gt;</code></li> <li><code>powershell -command \"Get-Process &lt;process&gt; -ErrorAction SilentlyContinue\"</code></li> <li><code>powershell -command \"netstat -an | select-string -pattern 'listening' | select-string -pattern '&lt;port&gt;'\"</code></li> <li><code>powershell -command \"Get-WmiObject Win32_Processor | Measure-Object -Property LoadPercentage -Average | Select Average\"</code></li> </ul>"},{"location":"user-administration/","title":"User Authn/Authz in phenix","text":"<p><code>phenix</code> provides three separate modes of user authentication (authn) and authorization (authz).</p> <ul> <li>disabled</li> <li>enabled</li> <li>proxy</li> </ul>"},{"location":"user-administration/#disabled-mode","title":"<code>disabled</code> Mode","text":"<p>When in <code>disabled</code> mode, no user authentication or authorization occurs. Users do not have to authenticate, and all actions are allowed.</p> <p>To use <code>disabled</code> mode, the UI should be built with <code>VUE_APP_AUTH=disabled</code> (if Docker is being used to build the UI, use Docker build arg <code>PHENIX_WEB_AUTH=disabled</code>) and the UI server should be started without the <code>-k/--jwt-signing-key</code> option set.</p>"},{"location":"user-administration/#enabled-mode","title":"<code>enabled</code> Mode","text":"<p>When in <code>enabled</code> mode, user authentication and authorization occurs within phenix directly. Users have to authenticate to the phenix UI, and certain actions are prohibited based on the role assigned to the user.</p> <p>To use <code>enabled</code> mode, the UI should be built with <code>VUE_APP_AUTH=enabled</code> (if Docker is being used to build the UI, use Docker build arg <code>PHENIX_WEB_AUTH=enabled</code>) and the UI server should be started with the <code>-k/--jwt-signing-key</code> (and optionally the <code>--jwt-lifetime</code>) option set.</p>"},{"location":"user-administration/#proxy-mode","title":"<code>proxy</code> Mode","text":"<p>When in <code>proxy</code> mode, user authentication is expected to occur in a reverse proxy that sits in front of phenix but user authorization still occurs within phenix directly. Users authenticate to the proxy, and certain actions are prohibited based on the role assigned to the user.</p> <p>To use <code>proxy</code> mode, the UI should be built with <code>VUE_APP_AUTH=proxy</code> (if Docker is being used to build the UI, use Docker build arg <code>PHENIX_WEB_AUTH=proxy</code>) and the UI server should be started with the <code>-k/--jwt-signing-key</code> and <code>--proxy-auth-header</code> (and optionally the <code>--jwt-lifetime</code>) options set.</p> <p>In addition, the reverse proxy should add a header to requests being proxied that contains the username of the authenticated user, with the name of the header matching what <code>--proxy-auth-header</code> is set to (for example, <code>--proxy-auth-header=X-phenix-user</code>).</p> <p>If a user is able to authenticate to the proxy but is not yet a user in phenix, they will be added as a phenix user automatically and assigned the <code>Disabled</code> role that will deny all actions until an admin user can assign them a different role.</p>"},{"location":"user-administration/#create-a-new-user","title":"Create a new user","text":"<p>There are three primary ways to create new users.</p> <ol> <li> <p>Choose the <code>Create Account</code> link off the login page and complete all fields    in the <code>Create a New Account</code> dialogue. This will initiate a message to an    administrator's account who can then activate the account, setting the    role(s) and resource name(s).</p> <p></p> <p></p> </li> <li> <p>From the <code>Users</code> tab, click the <code>+</code> button to create a new user. Here the    administrator will add the role(s) and resource    name(s).</p> <p></p> </li> <li> <p>Create a YAML or JSON file at <code>/etc/phenix/users.[yml|json]</code> with the    following structure. When the <code>phenix</code> UI starts, it looks for this file and    adds any users present in the file that are not already present in <code>phenix</code>.    For users in the file that already exist, <code>phenix</code> ensures the user role    matches what's in the file and updates it as necessary. This file is also    automatically watched, so any users added to the file while <code>phenix</code> is    running will automatically be added to <code>phenix</code>.</p> </li> </ol> <pre><code>ui:\n  users:\n    - &lt;username&gt;:&lt;password&gt;:&lt;role name&gt;\n    - ...\n</code></pre>"},{"location":"user-administration/#login","title":"Login","text":"<p>The login page is self-descriptive. Using the <code>Remember me</code> checkbox will set a token to local storage so that you can remove the requirement to enter a <code>Username</code> and <code>Password</code> each time the page or site is reloaded. </p> <p>If an administrator starts the UI server with the following command, authentication is enabled:</p> <pre><code>phenix ui -k &lt;some_string&gt;\n</code></pre> <p>Without the <code>-k</code> (or <code>--jwt-signing-key</code>), authentication is disabled.</p>"},{"location":"user-administration/#generating-user-authentication-tokens","title":"Generating User Authentication Tokens","text":"<p>From the <code>Users</code> tab, click the key icon next to the given user's name. A dialog box will pop up where you can enter in a description for the token to be created and an expiration date. This expiration date should be entered in Golang time duration. For example, <code>4320h</code> is valid and represents 4320 hours or about 6 months. After clicking <code>Create Token</code> a token should appear with the expiriation date.  </p> <p>This token can be used to authenticate when using the Phenix API. Specifically, you would include the following as a header in HTTP requests.</p> <pre><code>X-phenix-auth-token: Bearer &lt;TOKEN&gt;\n</code></pre>"},{"location":"user-administration/#user-administration","title":"User Administration","text":""},{"location":"user-administration/#updating-users","title":"Updating Users","text":"<p>An administrator is able to click on the username on the table in the Users tab to update a user. They can update <code>First Name</code> or <code>Last Name</code>, <code>Role</code>, <code>Experiment Names</code>, and <code>Resource Name(s)</code>.</p>"},{"location":"user-administration/#roles","title":"Roles","text":"<p><code>Global Admin</code> is the administrator level account and has access to all capabilities, to include user management. Global Admins also have access to all resources. The following table provides a high-level overview of all the available roles and their access rights.</p> Role Limits List Get Create Update Patch Delete Global Admin Can see and control absolutely anything/everything. E V U E V U E V U E V U E V U E V U Global Viewer Can see absolutely anything/everything, but cannot make any changes. E V U E V U Experiment Admin Can see and control anything/everything for assigned experiments, including VMs, but cannot create new experiments. E V E V V E V V V Experiment User Can see assigned experiments, and can control VMs within assigned experiments, but cannot modify experiments themselves. E V E V V Experiment Viewer Can see assigned experiments and VMs within assigned experiments, but cannot modify or control experiments or VMs. E V E V VM Viewer Can only see VM screenshots and access VM VNC, nothing else. V <p>Key: E - experiment resource, V - VM resource, U - user resource</p>"},{"location":"user-administration/#resources","title":"Resources","text":""},{"location":"user-administration/#resource-experiments","title":"Resource: <code>experiments</code>","text":"Verb list Desc get a list of all experiments Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped no Verb get Desc get a specific experiment Exp. Scoped yes Res. Scoped no Verb create Desc create a new experiment Exp. Scoped no Res. Scoped no Verb delete Desc delete a specific experiment Exp. Scoped yes Res. Scoped no"},{"location":"user-administration/#resource-experimentsstart","title":"Resource: <code>experiments/start</code>","text":"Verb update Desc start an experiment Exp. Scoped yes Res. Scoped no"},{"location":"user-administration/#resource-experimentsstop","title":"Resource: <code>experiments/stop</code>","text":"Verb update Desc stop an experiment Exp. Scoped yes Res. Scoped no"},{"location":"user-administration/#resource-experimentsschedule","title":"Resource: <code>experiments/schedule</code>","text":"Verb get Desc get current schedule for an experiment Exp. Scoped yes Res. Scoped no Verb create Desc schedule an experiment using schedule algorithm Exp. Scoped yes Res. Scoped no"},{"location":"user-administration/#resource-experimentstrigger","title":"Resource: <code>experiments/trigger</code>","text":"Verb create Desc trigger the running stage of an experiment Exp. Scoped yes Res. Scoped no"},{"location":"user-administration/#resource-experimentscaptures","title":"Resource: <code>experiments/captures</code>","text":"Verb list Desc get list of packet captures for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped yes (list is filtered to only include VMs in scope)"},{"location":"user-administration/#resource-experimentsfiles","title":"Resource: <code>experiments/files</code>","text":"Verb list Desc get list of files for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped no Verb get Desc get specific experiment file Exp. Scoped yes Res. Scoped no"},{"location":"user-administration/#resource-vms","title":"Resource: <code>vms</code>","text":"Verb list Desc get list of VMs for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped yes (list is filtered to only include VMs in scope) Verb get Desc get a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb patch Desc update a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb delete Desc delete a specific experiment VM Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-vmsstart","title":"Resource: <code>vms/start</code>","text":"Verb update Desc start a specific experiment VM Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-vmsstop","title":"Resource: <code>vms/stop</code>","text":"Verb update Desc stop a specific experiment VM Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-vmsredeploy","title":"Resource: <code>vms/redeploy</code>","text":"Verb update Desc redeploy a specific experiment VM Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-vmsscreenshot","title":"Resource: <code>vms/screenshot</code>","text":"Verb get Desc get screenshot for a specific experiment VM Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-vmsvnc","title":"Resource: <code>vms/vnc</code>","text":"Verb get Desc get VNC address for a specific experiment VM Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-vmscaptures","title":"Resource: <code>vms/captures</code>","text":"Verb list Desc get list of packet captures for a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb create Desc start a packet capture on a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb delete Desc stop all packet captures on a specific experiment VM Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-vmssnapshots","title":"Resource: <code>vms/snapshots</code>","text":"Verb list Desc get list of snapshots for a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb create Desc create a snapshot of a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb update Desc restore a specific experiment VM to a previous snapshot Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-vmscommit","title":"Resource: <code>vms/commit</code>","text":"Verb create Desc create a new backing image from a specific experiment VM Exp. Scoped yes Res. Scoped yes"},{"location":"user-administration/#resource-applications","title":"Resource: <code>applications</code>","text":"Verb list Desc get list of user applications Exp. Scoped no Res. Scoped yes (list is filtered to only include applications in scope)"},{"location":"user-administration/#resource-topologies","title":"Resource: <code>topologies</code>","text":"Verb list Desc get list of available topologies Exp. Scoped no Res. Scoped yes (list is filtered to only include topologies in scope)"},{"location":"user-administration/#resource-disks","title":"Resource: <code>disks</code>","text":"Verb list Desc get list of available backing images Exp. Scoped no Res. Scoped yes (list is filtered to only include backing images in scope)"},{"location":"user-administration/#resource-hosts","title":"Resource: <code>hosts</code>","text":"Verb list Desc get list of minimega cluster hosts Exp. Scoped no Res. Scoped yes (list is filtered to only include hosts in scope)"},{"location":"user-administration/#resource-users","title":"Resource: <code>users</code>","text":"Verb list Desc get list of users Exp. Scoped no Res. Scoped yes (list is filtered to only include users in scope) Verb get Desc get a specific user Exp. Scoped no Res. Scoped yes Verb create Desc create a new user Exp. Scoped no Res. Scoped no Verb patch Desc update an existing user Exp. Scoped no Res. Scoped yes Verb delete Desc delete an existing user Exp. Scoped no Res. Scoped yes"},{"location":"user-administration/#built-in-roles","title":"Built-In Roles","text":"<p>See the previous section for policy resource and verb descriptions.</p> <pre><code>case GLOBAL_ADMIN:\n  return Policies([]*Policy{\n    {\n      Experiments:   []string{\"*\"},\n      Resources:     []string{\"*\", \"*/*\"},\n      ResourceNames: []string{\"*\"},\n      Verbs:         []string{\"*\"},\n    },\n  })\ncase GLOBAL_VIEWER:\n  return Policies([]*Policy{\n    {\n      Experiments:   []string{\"*\"},\n      Resources:     []string{\"*\", \"*/*\"},\n      ResourceNames: []string{\"*\"},\n      Verbs:         []string{\"list\", \"get\"},\n    },\n  })\ncase EXP_ADMIN:\n  // must supply experiment names and resource names or nothing will authorize\n  return Policies([]*Policy{\n    {\n      Resources: []string{\"experiments\", \"experiments/*\"},\n      Verbs:     []string{\"list\", \"get\", \"update\"},\n    },\n    {\n      Resources: []string{\"vms\", \"vms/*\"},\n      Verbs:     []string{\"list\", \"get\", \"create\", \"update\", \"patch\", \"delete\"},\n    },\n    {\n      Resources:     []string{\"disks\"},\n      ResourceNames: []string{\"*\"},\n      Verbs:         []string{\"list\"},\n    },\n    {\n      Resources:     []string{\"hosts\"},\n      ResourceNames: []string{\"*\"},\n      Verbs:         []string{\"list\"},\n    },\n  })\ncase EXP_USER: // EXP_VIEWER + VM restart + VM update + VM capture\n  // must supply experiment names and resource names or nothing will authorize\n  return Policies([]*Policy{\n    {\n      Resources: []string{\"experiments\", \"experiments/*\"},\n      Verbs:     []string{\"list\", \"get\"},\n    },\n    {\n      Resources: []string{\"vms\", \"vms/*\"},\n      Verbs:     []string{\"list\", \"get\", \"patch\"},\n    },\n    {\n      Resources: []string{\"vms/redeploy\"},\n      Verbs:     []string{\"update\"},\n    },\n    {\n      Resources: []string{\"vms/captures\"},\n      Verbs:     []string{\"create\", \"delete\"},\n    },\n    {\n      Resources: []string{\"vms/snapshots\"},\n      Verbs:     []string{\"list\", \"create\", \"update\"},\n    },\n    {\n      Resources:     []string{\"hosts\"},\n      ResourceNames: []string{\"*\"},\n      Verbs:         []string{\"list\"},\n    },\n  })\ncase EXP_VIEWER:\n  // must supply experiment names and resource names or nothing will authorize\n  return Policies([]*Policy{\n    {\n      Resources: []string{\"experiments\", \"experiments/*\", \"vms\", \"vms/*\"},\n      Verbs:     []string{\"list\", \"get\"},\n    },\n    {\n      Resources:     []string{\"hosts\"},\n      ResourceNames: []string{\"*\"},\n      Verbs:         []string{\"list\"},\n    },\n  })\ncase VM_VIEWER:\n  // must supply experiment names and resource names or nothing will authorize\n  return Policies([]*Policy{\n    {\n      Resources: []string{\"vms\"},\n      Verbs:     []string{\"list\"},\n    },\n    {\n      Resources: []string{\"vms/screenshot\", \"vms/vnc\"},\n      Verbs:     []string{\"get\"},\n    },\n  })\n</code></pre>"},{"location":"vm-multi-action/","title":"VM Multi Action","text":""},{"location":"vm-multi-action/#selecting-vms","title":"Selecting VMs","text":""},{"location":"vm-multi-action/#from-the-web-ui","title":"From the Web-UI","text":"<p>The experiment must be started; click on the experiment name to enter the Running Experiment component. Within that component, click on the checkbox  adjacent to the <code>VM Name</code> column to select all the VMs.  Alternatively, the checkbox adjacent to a specific VM name can be used to select the VM.  Once one or more VMs are selected, a toolbar will appear to the left of the search text box.  The buttons on the toolbar are essentially the same as described in VMs.</p> <p></p>"},{"location":"vm-multi-action/#from-the-command-line-binary","title":"From the Command Line Binary","text":"<p>Not applicable.</p>"},{"location":"vm-multi-action/#searching-for-vms","title":"Searching for VMs","text":"<p>The search text box can be used to filter the list of VMs to only apply actions to the filtered list.</p>"},{"location":"vm-multi-action/#from-the-web-ui_1","title":"From the Web-UI","text":"<p>The experiment must be started; click on the experiment name to enter the Running Experiment component. Within that component, use the search textbox to find VMs by:</p> <ul> <li> <p>state - The keywords <code>running,shutdown,paused,capturing</code> can be used    to find  VMs in a specific state.  Also, the <code>not</code> keyword can be used   to negate search term(s) (i.e. <code>not running</code>)</p> </li> <li> <p>ipv4 address - VMs in a specific subnet can be found by entering the   subnet (i.e <code>192.168.2.0/30</code>)</p> </li> <li> <p>other fields (i.e. name, taps, tags) - All other fields will be   searched for a keyword contained within the field</p> </li> <li> <p>combine search terms - Search terms can be combined by using <code>or and</code>   keywords.  Parenthesis can also be used to group search terms. </p> </li> <li> <p>escape keywords - To find keywords that appear in a VM name use double   quotes. For example, to find a VM named <code>free_running</code>, type <code>\"running\"</code>.</p> </li> </ul>"},{"location":"vm-multi-action/#example","title":"Example","text":"<p>Multiple search terms</p> <p></p>"},{"location":"vm-multi-action/#from-the-command-line-binary_1","title":"From the Command Line Binary","text":"<p>Not applicable.</p>"},{"location":"vm-multi-action/#startingstopping-packet-captures","title":"Starting/Stopping Packet Captures","text":""},{"location":"vm-multi-action/#from-the-web-ui_2","title":"From the Web-UI","text":"<p>When a valid ipv4 subnet is entered, the <code>play</code> button adjacent to the IPv4 label will be enabled. To start capturing, press the <code>play</code> button.</p> <p></p> <p>Once there are valid captures, the <code>stop</code> button adjacent to the play button will be enabled. To stop all the catpures, press the <code>stop</code> button.</p> <p></p> <p>To stop all packet captures for all subnets, the term <code>capturing</code> can be entered in the search bar to find all the VMs with active packet captures.</p> <p></p>"},{"location":"vm-multi-action/#from-the-command-line-binary_2","title":"From the Command Line Binary","text":"<p>To start packet captures on running VMs for a specific subnet, use the following command.</p> <pre><code>phenix vm capture start-subnet &lt;experiment name&gt; &lt;subnet&gt;\n</code></pre> <p>To stop all packet captures for a specific subnet, use the following command.</p> <pre><code>phenix vm capture stop-subnet &lt;experiment name&gt; &lt;subnet&gt;\n</code></pre> <p>To stop all packet captures for an experiment, use the following command.</p> <pre><code>phenix vm capture stop-all &lt;experiment name&gt;\n</code></pre>"},{"location":"vm-multi-action/#stopped-experiment-component","title":"Stopped Experiment Component","text":"<p>Similar to the Running Experiment component, multiple VMs can be selected for the Stopped Experiment component.  In addition, VMs in the Stopped Experiment component can be searched by:</p> <ul> <li> <p>state - The keyword <code>dnb</code> can be used to find all VMs with the    <code>do not boot</code> flag set to <code>true</code>.  Also, the <code>not</code> keyword can be used   to negate search term(s) (i.e. <code>not dnb</code>)</p> </li> <li> <p>ipv4 address - VMs in a specific subnet can be found by entering the   subnet (i.e <code>192.168.2.0/30</code>)</p> </li> <li> <p>other fields (i.e. VM, host, disk) </p> </li> <li> <p>combine search terms - Search terms can be combined by using <code>or and</code>   keywords.  Parenthesis can also be used to group search terms. </p> </li> <li> <p>escape keywords - To find keywords that appear in a VM name use double   quotes. For example, to find a VM named <code>dnb_me</code>, type <code>\"dnb\"</code>.</p> </li> </ul>"},{"location":"vms/","title":"VMs","text":""},{"location":"vms/#vm-info","title":"VM Info","text":""},{"location":"vms/#from-the-web-ui","title":"From the Web-UI","text":"<p>The experiment must be started; click on the experiment name to enter the Running Experiment component. Within that component, click on the VM name and you will be presented with a VM information modal.</p> <p></p> <p>Available commands</p> <ul> <li><code>restore</code> a snapshot by clicking the play button next to the desired snapshot name.</li> </ul> <p>Buttons from left to right:</p> <ul> <li><code>pause</code> a running VM</li> <li>Create a <code>memory snapshot</code> of a running VM</li> <li>Create a <code>backing image</code> of a running VM</li> <li>Create a <code>snapshot</code> of a running VM</li> <li><code>record screenshot</code> of a running VM</li> <li><code>modify state</code> opens another toolbar of buttons</li> </ul>"},{"location":"vms/#modify-state-toolbar","title":"Modify State Toolbar","text":"<p>Buttons from left to right:</p> <ul> <li><code>redeploy</code> a running VM</li> <li><code>reset disk state</code> of a running VM</li> <li><code>restart</code> a running VM</li> <li><code>shutdown</code> a running VM</li> <li><code>kill</code> a running VM</li> <li><code>close</code> modify state toolbar</li> </ul>"},{"location":"vms/#from-the-command-line-binary","title":"From the Command Line Binary","text":"<p>There are two options for displaying the information for VMs in an experiment. First run  the following command to see information for all VMs in a given experiment.</p> <pre><code>phenix vm info &lt;experiment name&gt;\n</code></pre> <p>Or, run the following to see the information for a specific VM in an experiment.</p> <pre><code>phenix vm info &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#create-a-backing-image","title":"Create a Backing Image","text":""},{"location":"vms/#from-the-web-ui_1","title":"From the Web-UI","text":"<p>Click on the name of a running VM in a started experiment to access the VM information  modal.  Click the <code>create backing image</code> button as shown in the screenshot below.</p> <p></p>"},{"location":"vms/#from-the-command-line-binary_1","title":"From the Command Line Binary","text":"<p>Not applicable.</p>"},{"location":"vms/#create-a-memory-snapshot","title":"Create a Memory Snapshot","text":""},{"location":"vms/#from-the-web-ui_2","title":"From the Web-UI","text":"<p>Click on the name of a running VM in a started experiment to access the VM information modal.  Click the <code>memory snapshot</code> button as shown in the screenshot below.</p> <p></p>"},{"location":"vms/#from-the-command-line-binary_2","title":"From the Command Line Binary","text":"<p>To create an ELF memory dump, run the following command.</p> <pre><code>phenix vm memory-snapshot &lt;experiment name&gt; &lt;vm name&gt; &lt;snapshot file path&gt;\n</code></pre>"},{"location":"vms/#create-a-vm-snapshot","title":"Create a VM Snapshot","text":""},{"location":"vms/#from-the-web-ui_3","title":"From the Web-UI","text":"<p>Click on a running VM in a started experiment to access the VM information modal.  Click the <code>vm snapshot</code> button as shown in the screenshot below.</p> <p></p>"},{"location":"vms/#from-the-command-line-binary_3","title":"From the Command Line Binary","text":"<p>Not applicable.</p>"},{"location":"vms/#vm-vnc-access","title":"VM VNC Access","text":""},{"location":"vms/#from-the-web-ui_4","title":"From the Web-UI","text":"<p>The experiment must be started; click on the VM screenshot to open a new browser tab that provides VNC access to the VM.</p>"},{"location":"vms/#from-the-command-line-binary_4","title":"From the Command Line Binary","text":"<p>Not applicable.</p>"},{"location":"vms/#packet-capture","title":"Packet Capture","text":""},{"location":"vms/#from-the-web-ui_5","title":"From the Web-UI","text":"<p>Click on the name of the network tap on a running VM in a started experiment to  start a packet capture. The name of the network tap will turn green once a packet  capture has started. It is possible to start captures on multiple network taps.  However, when you stop packet capture, it will stop captures on all network taps.</p>"},{"location":"vms/#from-the-command-line-binary_5","title":"From the Command Line Binary","text":"<p>To start a packet capture, run the following command.</p> <pre><code>phenix vm capture start &lt;experiment name&gt; &lt;vm name&gt; &lt;iface index&gt; &lt;/path/to/out file&gt;\n</code></pre> <p>To stop all packet captures on a running VM, use the following command.</p> <pre><code>phenix vm capture stop &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#kill-a-vm","title":"Kill a VM","text":""},{"location":"vms/#from-the-web-ui_6","title":"From the Web-UI","text":"<p>Click on the name of a running VM in a started experiment to access the VM information  modal. Click the <code>modify state</code> button on the far right to open the modify state toolbar. Click the <code>kill</code> button as shown in the screenshot below.</p> <p></p> <p>Note: if you stop and then start the experiment again, that VM will run again  per the experiment configuration.</p>"},{"location":"vms/#from-the-command-line-binary_6","title":"From the Command Line Binary","text":"<p>To kill a VM, run the following command.</p> <pre><code>phenix vm kill &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#modify-the-network-connectivity","title":"Modify the Network Connectivity","text":""},{"location":"vms/#from-the-web-ui_7","title":"From the Web-UI","text":"<p>Click on the network for the desired VM in the Running Component to modify the  settings. Select from a pull down what network you want to switch the VM interface  you clicked on to. To revert back to previous setting, simply repeat selecting the  network interface you wish to change, and select the previous network setting.</p>"},{"location":"vms/#from-the-command-line-binary_7","title":"From the Command Line Binary","text":"<p>To connect a VM network interface to a different network, run the following command.</p> <pre><code>phenix vm net connect &lt;experiment name&gt; &lt;vm name&gt; &lt;iface index&gt; &lt;vlan id&gt;\n</code></pre> <p>To disconnect a VM network interface, run the following command.</p> <pre><code>phenix vm net disconnect &lt;experiment name&gt; &lt;vm name&gt; &lt;iface index&gt;\n</code></pre>"},{"location":"vms/#pause-a-vm","title":"Pause a VM","text":""},{"location":"vms/#from-the-web-ui_8","title":"From the Web-UI","text":"<p>Click on the name of a running VM in a started experiment to access the VM information  modal. To pause a VM, click on the <code>pause</code> button as shown in the screenshot below. To start a paused VM, that same button will become a green play button; simply  click it to start.</p> <p></p>"},{"location":"vms/#from-the-command-line-binary_8","title":"From the Command Line Binary","text":"<p>To pause a VM, run the following command.</p> <pre><code>phenix vm pause &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre> <p>To resume a paused VM, run the following command.</p> <pre><code>phenix vm resume &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#redeploy-a-vm","title":"Redeploy a VM","text":""},{"location":"vms/#from-the-web-ui_9","title":"From the Web-UI","text":"<p>Click on the name of a running VM in a started experiment to access the VM information  modal. Click the <code>modify state</code> button on the far right to open the modify state toolbar. Click the <code>redeploy</code> button as shown in the screenshot below.</p> <p></p>"},{"location":"vms/#from-the-command-line-binary_9","title":"From the Command Line Binary","text":"<p>To redploy a VM, run the following command.</p> <pre><code>phenix vm redeploy &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#reset-disk-state","title":"Reset Disk State","text":""},{"location":"vms/#from-the-web-ui_10","title":"From the Web-UI","text":"<p>Click on the name of a running VM in a started experiment to access the VM information  modal. Click the <code>modify state</code> button on the far right to open the modify state toolbar. Click the <code>reset disk state</code> button as shown in the screenshot below.</p> <p></p>"},{"location":"vms/#from-the-command-line-binary_10","title":"From the Command Line Binary","text":"<p>To reset the first disk to the initial pre-boot state, run the following command.</p> <pre><code>phenix vm reset-disk &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#restart-a-vm","title":"Restart a VM","text":""},{"location":"vms/#from-the-web-ui_11","title":"From the Web-UI","text":"<p>Click on the name of a running VM in a started experiment to access the VM information  modal. Click the <code>modify state</code> button on the far right to open the modify state toolbar. Click the <code>restart</code> button as shown in the screenshot below.</p> <p></p>"},{"location":"vms/#from-the-command-line-binary_11","title":"From the Command Line Binary","text":"<p>To restart a VM, run the following command.</p> <pre><code>phenix vm restart &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#resume-a-vm","title":"Resume a VM","text":""},{"location":"vms/#from-the-web-ui_12","title":"From the Web-UI","text":"<p>Click on the name of the paused VM in a started experiment to access the VM information  modal. Click the green play button (previously the pause button, furthest button to the  left).</p>"},{"location":"vms/#from-the-command-line-binary_12","title":"From the Command Line Binary","text":"<p>To resume a paused VM, run the following command.</p> <pre><code>phenix vm resume &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#shutdown-a-vm","title":"Shutdown a VM","text":""},{"location":"vms/#from-the-web-ui_13","title":"From the Web-UI","text":"<p>Click on the name of a running VM in a started experiment to access the VM information  modal. Click the <code>modify state</code> button on the far right to open the modify state toolbar. Click the <code>shutdown</code> button as shown in the screenshot below.</p> <p></p>"},{"location":"vms/#from-the-command-line-binary_13","title":"From the Command Line Binary","text":"<p>To shutdown a VM, run the following command.</p> <pre><code>phenix vm shutdown &lt;experiment name&gt; &lt;vm name&gt;\n</code></pre>"},{"location":"vms/#modify-vm-settings","title":"Modify VM Settings","text":""},{"location":"vms/#from-the-web-ui_14","title":"From the Web-UI","text":"<p>There are two ways to modify VM settings:</p> <ol> <li>Click on a stopped experiment to access the Stopped Component. You are able to edit the  following:<ul> <li>Host name</li> <li>CPUs</li> <li>Memory</li> <li>Disk</li> <li>Do not boot flag</li> </ul> </li> <li>From a running experiment, click on the VM name and then the redeploy button (yellow power button, second from the right on the modal footer). You are able to edit the following:<ul> <li>CPU</li> <li>Memory</li> <li>Disk</li> <li>Replication of original injections</li> </ul> </li> </ol>"},{"location":"vms/#from-the-command-line-binary_14","title":"From the Command Line Binary","text":"<p>This command is not yet implemented. For now, you can edit the stopped experiment directly with the following command.</p> <pre><code>phenix cfg edit topology/&lt;topology name&gt;\n</code></pre> <p>This will launch the system editor where you can directly modify the experiment settings.</p>"},{"location":"vms/#applying-actions-to-multiple-vms","title":"Applying Actions to Multiple VMs","text":"<p>Note</p> <p>See VM Multi Action for documentation on applying actions to multiple VMs at once.</p>"}]}